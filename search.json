[{"title":"Ubuntu安裝Codimd","url":"/2020/07/05/codimd-install/","content":"相關介紹githubmanual-deployment\n安裝nodejs# 安裝版本庫$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -# 安裝nodejs$ apt install -y nodejs# 查看nodejs版本$ node -v# 查看npm版本$ npm -v\n\n安裝相關依賴$ npm install -g yarn$ npm install -g node-gyp$ npm install -g sqlite3$ npm install -g webpack\n\n安裝codimd設置環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport PATH=$PATH:NODE_ENV=production\n\n抓取項目(&#x2F;opt)$ git clone https://github.com/hackmdio/codimd.git\n\n\n\n初始化配置先修改安裝配置bin&#x2F;setup\t.\t.\t.echo &quot;install packages&quot;npm install --production --unsafe-perm=true --allow-root\t.\t.\t.\n執行安裝配置$ sudo bash bin/setup\n\n修改環境配置編輯config.json\n&#123;\t.\t.\t.    &quot;production&quot;: &#123;        &quot;host&quot;: &quot;0.0.0.0&quot;, // 設置來源        &quot;port&quot;: 3000, // 設置port        &quot;loglevel&quot;: &quot;info&quot;,        &quot;hsts&quot;: &#123;            &quot;enable&quot;: true,            &quot;maxAgeSeconds&quot;: 31536000,            &quot;includeSubdomains&quot;: true,            &quot;preload&quot;: true        &#125;,        &quot;csp&quot;: &#123;            &quot;enable&quot;: true,            &quot;directives&quot;: &#123;            &#125;,            &quot;upgradeInsecureRequests&quot;: &quot;auto&quot;,            &quot;addDefaults&quot;: true,            &quot;addDisqus&quot;: true,            &quot;addGoogleAnalytics&quot;: true        &#125;,        &quot;db&quot;: &#123;            &quot;username&quot;: &quot;帳號&quot;, // 設置db帳號            &quot;password&quot;: &quot;密碼&quot;, // 設置db密碼            &quot;database&quot;: &quot;資料庫&quot;, // 設置資料庫名稱            &quot;host&quot;: &quot;localhost&quot;,            &quot;port&quot;: &quot;3306&quot;,            &quot;dialect&quot;: &quot;mysql&quot;        &#125;        &quot;linkifyHeaderStyle&quot;: &quot;gfm&quot;    &#125;&#125;\n\n編輯.sequelizerc\nvar path = require(&#x27;path&#x27;);module.exports = &#123;    &#x27;config&#x27;:          path.resolve(&#x27;config.json&#x27;),    &#x27;migrations-path&#x27;: path.resolve(&#x27;lib&#x27;, &#x27;migrations&#x27;),    &#x27;models-path&#x27;:     path.resolve(&#x27;lib&#x27;, &#x27;models&#x27;),    &#x27;url&#x27;:             &#x27;mysql://&#123;db帳號&#125;:&#123;db密碼&#125;@localhost:3306/codimd&#x27;&#125;\n\n編輯lib&#x2F;config&#x2F;default.js\n... allowAnonymous: false, // 關閉匿名登入 allowAnonymousEdits: false, // 關閉匿名編輯... email: true, // 開啟email使用 allowEmailRegister: true, // 允許email註冊...\n\n啟動$ npm run build // 重新編輯前端頁面$ node app.js // 啟動服務\n\n\n\n","categories":["linux"],"tags":["linux","ubuntu","codimd","hackmd"]},{"title":"Docker Hub PAT 申請指南","url":"/2025/10/11/docker-hub-pat-guide/","content":"Docker Hub PAT 申請指南什麼是 Docker Hub PAT？Docker Hub Personal Access Token (PAT) 是 Docker Hub 提供的身份驗證機制，用於替代傳統的使用者名稱和密碼組合。PAT 提供了更安全的方式來存取 Docker Hub 的 API 和映像倉庫。\nPAT 的主要優勢：\n安全性：避免在腳本或配置中使用明文密碼\n權限控制：可以設定特定的權限範圍\n易於管理：可以獨立撤銷和更新，不影響帳戶密碼\n審計追蹤：提供更好的存取記錄和監控\n\n為什麼需要使用 PAT？在以下情況下，建議使用 PAT 替代密碼：\n\nCI&#x2F;CD 流程：在自動化部署中進行映像推送和拉取\n本地開發：在 Minikube 或其他本地環境中拉取私有映像\n腳本自動化：需要程式化存取 Docker Hub API\n企業環境：符合企業安全政策和最佳實務\n\n\n\n\nPAT 申請步驟步驟 1：登入 Docker Hub\n開啟瀏覽器，前往 Docker Hub\n點選右上角的 Sign In 按鈕\n輸入您的 Docker Hub 帳號和密碼進行登入\n\n步驟 2：進入帳戶設定\n登入後，點選右上角的帳戶頭像\n從下拉選單中選擇 Account Settings\n\n步驟 3：進入 Personal Access Tokens\n在左側導航選單中點選 Settings\n展開 Settings 選單，選擇 Personal access tokens\n您會看到 Personal access tokens 頁面，顯示現有的權杖列表\n\n\n\n步驟 4：建立新的存取權杖\n點選右上角的 Generate new token 按鈕\n進入 Create access token 頁面\n\n\n\n步驟 5：配置權杖設定\nAccess token description：輸入有意義的描述名稱\n\n範例：minikube-pull、ci-cd-pipeline、local-development\n\n\nExpiration date：選擇權杖的過期時間\n\nNone：永不過期（不建議用於生產環境）\n30 days：30 天後過期\n90 days：90 天後過期\nCustom：自訂過期日期\n\n\nAccess permissions：選擇適當的權限級別\n\nPublic Repo Read-only：只能讀取公開倉庫（預設選項，推薦用於拉取）\nRead-only：只能讀取所有可存取的倉庫\nRead &amp; Write：可以讀取和寫入倉庫\nRead, Write, Delete：完整權限（謹慎使用）\n\n\n點選 Generate 按鈕建立權杖\n\n\n步驟 6：複製和保存權杖權杖建立成功後，您會看到 Copy access token 頁面：\n⚠️ 重要提醒：個人存取權杖只會顯示一次，無法儲存且之後無法再檢索\n\n權杖資訊確認：\n\nAccess token description：您設定的描述名稱（如：test）\nExpires on：過期時間（如：Never 表示永不過期）\nAccess permissions：權限級別（如：Public Repo Read-only）\n\n\n複製權杖：\n\n在步驟 1 中，複製 Docker CLI 登入指令：docker login -u &lt;username&gt;\n點選右側的 Copy 按鈕複製指令\n\n\n複製個人存取權杖：\n\n在步驟 2 中，顯示完整的個人存取權杖字串\n權杖格式類似：dckr_pat_abcdefghijk00000\n點選右側的 Copy 按鈕複製權杖\n\n\n安全保存：\n\n立即將權杖保存在安全的位置（如密碼管理器）\n記錄權杖的用途和建立日期\n\n\n完成申請：\n\n點選 Back to access tokens 按鈕返回權杖管理頁面\n\n\n\n\n\n使用說明根據頁面提示，您可以使用此權杖作為密碼，透過 Docker CLI 客戶端登入：\n\n執行登入指令：\ndocker login -u &lt;username&gt;\n\n在密碼提示時輸入個人存取權杖：\nPassword: &lt;password&gt;\n\n權杖管理介面說明在 Personal access tokens 頁面中，您可以看到：\n\nDescription：權杖的描述名稱\nScope：權杖的權限範圍\nStatus：權杖狀態（Active&#x2F;Inactive）\nSource：建立方式（Manual&#x2F;Auto-generated）\nCreated：建立時間\nLast used：最後使用時間\nExpiration date：過期日期\n\n您可以透過右側的操作選單來管理現有的權杖，包括查看詳細資訊、停用或刪除權杖。\n使用 PAT 進行身份驗證在命令列中使用根據 Docker Hub 提供的指引，推薦使用以下方式：\n# 方法一：使用 Docker Hub 提供的登入指令docker login -u &lt;username&gt;# 在密碼提示時輸入 PAT，例如：# Password: dckr_pat_abcdefghijk00000# 方法二：直接在指令中指定（較不安全，會在命令歷史中留下記錄）docker login -u &lt;username&gt; -p &lt;password&gt;# 方法三：互動式登入（最安全）docker login# Username: &lt;username&gt;# Password: &lt;password&gt;\n\n最佳實務：建議使用方法一或方法三，避免在指令行中直接暴露 PAT。\n在 Kubernetes 中使用# 建立 Docker Registry Secretkubectl create secret docker-registry regcred \\  --docker-server=https://index.docker.io/v1/ \\  --docker-username=&lt;username&gt; \\  --docker-password=&lt;password&gt; \\  --docker-email=&lt;email&gt;\n\n在 CI&#x2F;CD 中使用# GitHub Actions 範例- name: Login to Docker Hub  uses: docker/login-action@v2  with:    username: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;    password: $&#123;&#123; secrets.DOCKERHUB_TOKEN &#125;&#125;\n\nPAT 管理最佳實務權限設定建議\n最小權限原則：只授予必要的權限\n\n僅拉取映像：使用 Public Repo Read-only 或 Read-only\n需要推送映像：使用 Read &amp; Write\n避免使用 Read, Write, Delete 權限，除非絕對必要\n\n\n專用權杖：為不同用途建立專用的 PAT\n\n開發環境：dev-environment-pat\n生產 CI&#x2F;CD：prod-pipeline-pat\n個人使用：personal-tools-pat\n\n\n過期時間設定：\n\n開發測試：建議設定 30-90 天\n生產環境：建議設定 90 天並定期輪換\n避免使用 None（永不過期）選項\n\n\n\n安全性考量\n定期輪換：建議每 3-6 個月更新一次 PAT\n安全存儲：\n使用環境變數而非硬編碼\n存儲在密碼管理器中\n在 CI&#x2F;CD 中使用 Secrets 管理\n\n\n監控使用：定期檢查 PAT 的使用情況和存取記錄\n\n權杖管理在 Docker Hub 的 Personal access tokens 頁面中，您可以：\n# 查看當前的 PAT 資訊# 包含：Description、Scope、Status、Source、Created、Last used、Expiration date# 管理現有權杖# - 點選權杖右側的三點選單# - 選擇 &quot;View details&quot;、&quot;Deactivate&quot; 或 &quot;Delete&quot;# - 建議定期清理不再使用的權杖\n\n權杖狀態說明：\n\nActive：權杖正常可用\nInactive：權杖已停用\nManual：手動建立的權杖\nAuto-generated：系統自動生成的權杖（如透過 Docker Desktop）\n\n疑難排解常見問題1. 權杖驗證失敗可能原因：\n\n權杖已過期或被撤銷\n權限不足\n使用者名稱錯誤\n\n解決方法：\n# 檢查登入狀態docker info# 重新登入docker logoutdocker login# 確認權杖權限是否足夠\n\n2. 無法拉取私有映像檢查項目：\n\nPAT 是否具有私有倉庫讀取權限\n映像名稱和標籤是否正確\n網路連線是否正常\n\n# 測試拉取公開映像docker pull hello-world# 檢查映像倉庫狀態docker search &lt;your-image-name&gt;\n\n3. Kubernetes 中無法使用 Image Pull Secret# 檢查 Secret 是否正確建立kubectl get secrets# 查看 Secret 詳細資訊kubectl describe secret regcred# 測試 Pod 中的映像拉取kubectl run test-pod --image=&lt;your-private-image&gt; --dry-run=client -o yaml\n\n權杖續期和更新定期檢查\n登入 Docker Hub\n前往左側選單的 Settings &gt; Personal access tokens\n檢查權杖列表中的 Last used 時間和 Expiration date\n透過右側選單移除不再使用的權杖\n\n更新流程\n在 Personal access tokens 頁面點選 Generate new token\n建立新的 PAT 並設定適當的過期時間\n在所有使用舊 PAT 的地方更新為新 PAT\n測試新 PAT 是否正常運作\n在舊權杖的右側選單中選擇 Delete 來撤銷舊的 PAT\n\n自動化更新提醒建議設定日曆提醒或使用監控工具，定期檢查和更新 PAT，確保服務的持續可用性。\n透過正確申請和管理 Docker Hub PAT，您可以提高 Docker 映像管理的安全性，同時保持開發和部署流程的順暢運行。\n","categories":["docker","docker-hub"],"tags":["docker"]},{"title":"Ubuntu安裝Docker","url":"/2021/08/21/docker-install/","content":"docker是目前容器化部屬最火紅的方案廢話不多說現在趕快來看看怎麼安裝吧!\n安裝$ sudo apt update$ sudo install docker.io\n\n\n\n查看版本# 查看版本$ docker versionClient: Version:           20.10.7 API version:       1.41 Go version:        go1.13.8 Git commit:        20.10.7-0ubuntu1~20.04.1 Built:             Wed Aug  4 22:52:25 2021 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Engine:  Version:          20.10.7  API version:      1.41 (minimum version 1.12)  Go version:       go1.13.8  Git commit:       20.10.7-0ubuntu1~20.04.1  Built:            Wed Aug  4 19:07:47 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.5.2-0ubuntu1~20.04.2  GitCommit: runc:  Version:          1.0.0~rc95-0ubuntu1~20.04.2  GitCommit: docker-init:  Version:          0.19.0  GitCommit:\n\n測試$ docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/\n\n補充如果我們希望docker可以用特定的user執行的話可以參照以下\n# 將用戶加入docker群組中$ sudo usermod -aG docker $USER# 套用新的群組設定$ sudo newgrp docker","categories":["docker"],"tags":["linux","ubuntu","docker"]},{"title":"Docker 基本介紹","url":"/2025/11/16/docker-intro/","content":"Docker 基本介紹架構總覽\n\n上圖展示了 Docker 完整架構，包含 Docker 客戶端、Docker 守護程序、容器運行時、映像檔倉庫等核心元件及其互動關係\nDocker 如何運作？Docker 采用客戶端-伺服器架構，主要包含以下工作流程：\n\n開發階段：使用 Dockerfile 定義應用程式環境\n建構階段：透過 docker build 將 Dockerfile 轉換為映像檔\n分享階段：將映像檔推送到 Docker Registry 進行分享\n部署階段：在任何支援 Docker 的環境中運行容器\n\n這個流程確保了「一次建構，到處運行」的目標。\n\n\n\nDocker EngineDocker 的核心運行引擎\n\n負責管理容器的整個生命週期\n包含 Docker 守護程序（dockerd）和 REST API\n提供容器的建立、啟動、停止和刪除等功能\n\nContainer（容器）應用程式的輕量化運行環境\n\n基於映像檔建立的可執行實例\n提供隔離的運行環境，包含應用程式及其所有依賴\n相較於虛擬機器，具有更快的啟動速度和更低的資源消耗\n每個容器都有獨立的檔案系統、網路和程序空間\n\nImage（映像檔）容器的唯讀模板\n\n包含執行應用程式所需的所有檔案、函式庫和設定\n採用分層架構，支援增量更新和快速部署\n具有不可變性，確保環境一致性\n可以透過 Dockerfile 自動化建構\n\nDockerfile映像檔的建構腳本\n\n定義映像檔建構過程的文字檔案\n包含一系列指令，如 FROM、RUN、COPY、CMD 等\n實現基礎設施即程式碼（Infrastructure as Code）\n支援版本控制和自動化建構\n\n\n提示Dockerfile 是實現可重現部署的關鍵，建議遵循最佳實踐來優化映像檔大小和安全性\n\nDocker Registry映像檔的儲存和分發中心\n\n提供映像檔的上傳、下載和版本管理\nDocker Hub 是官方的公共註冊中心\n支援私有註冊中心，滿足企業安全需求\n實現映像檔的集中管理和團隊協作\n\nVolume（資料卷）持久化資料儲存\n\n解決容器重啟時資料遺失的問題\n提供容器間的資料共享機制\n支援多種儲存驅動，如本機儲存、網路儲存等\n資料生命週期獨立於容器生命週期\n\nNetwork（網路）容器間的通訊管理\n\n提供容器與外部世界的網路連接\n支援多種網路驅動模式：\nbridge: 預設網路模式，適用於單機容器通訊\nhost: 直接使用主機網路，提供最佳性能\noverlay: 跨主機容器通訊，適用於叢集環境\nnone: 無網路存取，適用於安全要求較高的場景\n\n\n\n\n註解適當的網路配置對於容器安全性和性能至關重要\n\nDocker Compose多容器應用程式的編排工具\n\n透過 YAML 檔案定義和管理多容器應用程式\n簡化複雜應用程式的部署和管理\n支援服務依賴關係和啟動順序控制\n提供開發、測試和生產環境的一致性\n\n\n重要提示Docker Compose 非常適合開發環境和小規模部署，對於大規模生產環境建議使用 Kubernetes 等編排工具\n\n安裝 DockerDocker 提供了跨平台的安裝支援。以下將介紹最常用的安裝方式和注意事項。\n推薦安裝方式Windows&#x2F;macOS 使用者：直接下載 Docker Desktop，這是最簡單且完整的解決方案。\nLinux 使用者：使用以下方式之一：\n\n推薦：官方安裝腳本（最新版本）\n替代：套件管理器安裝（簡單快速）\n\n系統需求\n\n\n平台\n最低需求\n建議配置\n\n\n\nLinux\n64位元、Kernel 3.10+\nUbuntu 20.04+、Debian 10+、CentOS 8+\n\n\nWindows\nWindows 10 Pro 64位元\nWindows 11 + WSL 2\n\n\nmacOS\nmacOS 10.15+\nmacOS 12+ 含 Apple Silicon 支援\n\n\n方法一：官方一鍵安裝腳本（推薦）這是 Docker 官方提供的最簡單安裝方式：\n# 下載並執行官方安裝腳本curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh# 啟動 Docker 服務sudo systemctl enable --now docker# 將使用者加入 docker 群組sudo usermod -aG docker $USER# 重新載入群組設定newgrp docker\n\n方法二：手動安裝（Ubuntu&#x2F;Debian）如果您需要更精確的控制，可以使用手動安裝：\n# 更新套件索引sudo apt update# 安裝必要的套件sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release# 添加 Docker 官方 GPG 金鑰curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 添加 Docker 軟體源echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 更新套件索引並安裝 Dockersudo apt updatesudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 啟動 Docker 服務並設定為開機自動啟動sudo systemctl enable --now docker# 將目前使用者加入 docker 群組，避免每次都需要 sudosudo usermod -aG docker $USER\n\n方法三：套件管理器安裝（簡單快速）適用於快速測試或學習環境：\n# Ubuntu/Debiansudo apt update &amp;&amp; sudo apt install -y docker.io docker-compose-plugin# CentOS/RHELsudo yum install -y docker docker-compose-plugin# 啟動服務並設定開機自啟sudo systemctl enable --now dockersudo usermod -aG docker $USERnewgrp docker\n\n安裝後必要步驟無論使用哪種安裝方式，都需要完成以下步驟：\n1. 驗證安裝# 檢查 Docker 版本docker --version# 檢查 Docker 狀態docker info# 執行測試容器docker run --rm hello-world\n\n2. 確認權限設定# 確認使用者在 docker 群組中groups $USER | grep docker# 如果沒有，執行以下指令：sudo usermod -aG docker $USERnewgrp docker\n\n\n安全提醒：將使用者加入 docker 群組會給予該使用者等同 root 的 Docker 操作權限。在生產環境中請謹慎考慮安全性。\n\nWindows 和 macOS 安裝這兩個平台的安裝非常簡單：\n\n下載 Docker Desktop\n執行安裝檔並遵循安裝精靈\n安裝完成後重新啟動電腦（Windows）或啟動應用程式（macOS）\n等待 Docker 服務啟動完成\n使用上述驗證步驟確認安裝成功\n\n安裝 Docker ComposeDocker Compose 是用於定義和管理多容器 Docker 應用程式的工具。現代版本的 Docker 已經內建 Compose 功能，但您也可以單獨安裝 Docker Compose。\n檢查是否已安裝現代版本的 Docker Desktop 和 Docker Engine 已經內建了 Docker Compose：\n# 檢查 Docker Compose 版本（新版語法）docker compose version# 檢查 Docker Compose 版本（舊版語法）docker-compose --version\n\nLinux 手動安裝 Docker Compose如果您的系統沒有內建 Docker Compose，可以手動安裝。有兩種主要的安裝方式：\n方法一：作為 Docker CLI 插件安裝（推薦）# 設定 Docker 配置目錄DOCKER_CONFIG=$&#123;DOCKER_CONFIG:-$HOME/.docker&#125;mkdir -p $DOCKER_CONFIG/cli-plugins# 下載 Docker Compose 插件curl -SL https://github.com/docker/compose/releases/download/v2.24.5/docker-compose-linux-x86_64 \\  -o $DOCKER_CONFIG/cli-plugins/docker-compose# 給予執行權限chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose\n\n方法二：作為獨立執行檔安裝# 下載最新版本的 Docker Composesudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 給予執行權限sudo chmod +x /usr/local/bin/docker-compose# 建立軟連結（可選）sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n\n兩種安裝方式的區別\n\n\n特性\n插件安裝（方法一）\n獨立安裝（方法二）\n\n\n\n安裝位置\n~/.docker/cli-plugins/\n/usr/local/bin/\n\n\n權限需求\n用戶權限即可\n需要 sudo 權限\n\n\n使用語法\ndocker compose\ndocker-compose\n\n\n整合性\n與 Docker CLI 深度整合\n獨立運行\n\n\n更新方式\n替換插件檔案\n重新下載執行檔\n\n\n系統影響\n僅影響當前用戶\n全系統可用\n\n\nDocker 版本\n需要 Docker 20.10+\n支援較舊版本\n\n\n推薦使用插件安裝的原因：\n\n不需要 sudo 權限，更安全\n與 Docker CLI 更好的整合\n支援新的 docker compose 語法\n更容易管理和更新\n\n使用套件管理器安裝Ubuntu&#x2F;Debian：\nsudo apt install -y docker-compose-plugin\n\nCentOS&#x2F;RHEL：\nsudo yum install -y docker-compose-plugin\n\n驗證安裝# 驗證 Docker Compose 安裝docker compose version# 查看幫助資訊docker compose --help\n\n新舊語法差異\n新版語法：docker compose （推薦使用）\n舊版語法：docker-compose\n\n新版 Docker Compose 作為 Docker CLI 的插件，提供更好的整合性和性能。\n\n完整環境驗證完成 Docker 和 Docker Compose 安裝後，使用以下步驟驗證整個環境：\n# 1. 檢查 Docker 基本狀態docker --version &amp;&amp; docker compose version# 2. 檢查 Docker 服務狀態docker info | grep -E &quot;Server Version|Storage Driver|Cgroup Driver&quot;# 3. 執行簡單的容器測試docker run --rm hello-world# 4. 測試 Docker Compose 功能echo &#x27;version: &quot;3.8&quot;services:  test:    image: hello-world&#x27; &gt; docker-compose.ymldocker compose updocker compose downrm docker-compose.yml# 5. 清理測試資源docker system prune -f\n\n如果以上所有步驟都成功執行，恰喜您！Docker 環境已經準備就緒，可以開始您的容器化之旅了！\n\n下一步學習建議現在您已經了解了 Docker 的核心概念並完成了安裝，接下來建議：\n\n學習基本指令：熟悉 docker run、docker build、docker ps 等常用指令\n編寫 Dockerfile：學習如何建立自己的映像檔\n使用 Docker Compose：管理多容器應用程式\n探索實際專案：將現有應用程式容器化\n\n","categories":["docker"],"tags":["docker"]},{"title":"Elasticsearch+Kibana+Logstash環境安裝","url":"/2019/10/20/elk-install/","content":"在分散式系統底下我們需要查詢log紀錄總不可能需要一台一台機器上去查看紀錄這個時候我們就會需要有個服務幫我們達成這個目的\nelasticsearch就很適合來幫我們完成這個任務\nelasticsearch官網\n\n\n安裝JDK請參考之前的文章\n\nelasticsearch佈署elasticsearch是一個分散式的儲存系統，屬於NoSQL資料庫的一種elasticsearch介紹\n#下載安裝檔$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-amd64.deb#下載驗證檔$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-amd64.deb.sha512#檢查檔案$ shasum -a 512 -c elasticsearch-7.4.0-amd64.deb.sha512#執行安裝$ sudo dpkg -i elasticsearch-7.4.0-amd64.deb\n\n修改配置檔案首先我們要先修改elasticsearch記憶體的使用量修改elasticsearch使用的記憶體，設定為主機的50%記憶體\n#/etc/elasticsearch/jvm.options-Xms1g  # Xms 記憶體使用下限-Xmx1g  # Xmx 記憶體使用上限\n\n修改設定檔#/etc/elasticsearch/elasticsearch.yml#設置服務名稱cluster.name: elk_elasticsearch#設置節點名稱node.name: elk_node#設置為主要結點node.master: true#允許節點儲存數據node.data: true#path.data: /var/lib/elasticsearch#path.logs: /var/log/elasticsearch#綁定來源network.bind_host: 0.0.0.0#綁定對外服務端口http.port: 9200#綁定節點通信端口transport.tcp.port: 9300#啟用資料壓縮transport.tcp.compress: true#集群發現節點列表discovery.seed_hosts: [&quot;127.0.0.1:9300&quot;]#設置主要節點列表cluster.initial_master_nodes: [&quot;127.0.0.1&quot;]\n\n測試#啟動服務$ service elasticsearch start#測試$ curl http://127.0.0.1:9200&#123;  &quot;name&quot; : &quot;elk_node&quot;,  &quot;cluster_name&quot; : &quot;elk_service&quot;,  &quot;cluster_uuid&quot; : &quot;SRb6b1RaTaewA_OK2C7fMA&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.4.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;deb&quot;,    &quot;build_hash&quot; : &quot;22e1767283e61a198cb4db791ea66e3f11ab9910&quot;,    &quot;build_date&quot; : &quot;2019-09-27T08:36:48.569419Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.2.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;\n\nkibana佈署kibana是elasticsearch可視化的重要元件kibana介紹\n#下載安裝檔$ wget https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-amd64.deb#下載驗證檔$ wget https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-amd64.deb.sha512#檢查檔案$ shasum -a 512 -c kibana-7.4.0-amd64.deb.sha512#執行安裝$ sudo dpkg -i kibana-7.4.0-amd64.deb\n\n修改配置檔案#/etc/kibana/kibana.yml#綁定對外服務端口server.port: 5601#綁定來源server.host: &quot;0.0.0.0&quot;#設置服務名稱server.name: &quot;elk_kibana&quot;#設置elasticsearch節點列表elasticsearch.hosts: [&quot;http://127.0.0.1:9200&quot;]#設置索引kibana.index: &quot;.kibana&quot;設置log路徑logging.dest: /var/log/kibana/kibana.log設置中文化i18n.locale: &quot;zh-CN&quot;\n\n建立log目錄#建立目錄$ mkdir /var/log/kibana#修改使用者權限$ chown kibana:kibana /var/log/kibana\n\n測試#啟動服務$ service kibana start\n測試網址http://127.0.0.1:5601\n\n\n\n\nlogstash佈署logstash是負責幫我們收集各種log資料的收集器logstash介紹\n#下載安裝檔$ wget https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.deb#下載驗證檔$ wget https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.deb.sha512#檢查檔案$ shasum -a 512 -c logstash-7.4.0.deb.sha512#執行安裝$ sudo dpkg -i logstash-7.4.0.deb\n\n修改配置檔案#/etc/logstash/conf.d/30-log.conf# Sample Logstash configuration for creating a simple# Beats -&gt; Logstash -&gt; Elasticsearch pipeline.input &#123;  beats &#123;    port =&gt; 5044  &#125;&#125;output &#123;  elasticsearch &#123;    hosts =&gt; [&quot;http://localhost:9200&quot;]    index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;    #user =&gt; &quot;elastic&quot;    #password =&gt; &quot;changeme&quot;  &#125;&#125;\n\n檢查設定檔$ /usr/share/logstash/bin/logstash --config.test_and_exit -f /etc/logstash/conf.d/30-log.conf...Configuration OK\n\n啟動服務#啟動服務$ service logstash start\n\n基本上elk環境安裝就到這裡之後有空再補上log server使用方式\n","categories":["elasticsearch"],"tags":["elasticsearch","kibana","logstash","佈署"]},{"title":"GitLab搭建與中文化","url":"/2018/03/23/gitlab-install/","content":"網路上已有蠻多類似的文章，我就不再過多的論述了就寫寫佈署的時一些問題就好\ngitlab佈署直接上官網gitlab官網gitlab中文社群\n我佈署的環境是virtualbox+ubuntu基本上照著官網的install指令去佈署就能成功佈署最新版本\n如果是要另外進行中文化的佈署就必需去中文社群看看有沒有對應的版本中文化社群\n例如我佈署的gitlab版本是8.8.9那我就需要找到中文化對應的版本p.s 版號只需要對應前兩個版號就可以了\n那該如何指定安裝指定的版號\n官網提供的安裝指令應該如下：\n$ sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; apt-get install gitlab-ee\n上面的指令其實是預先設定好gitlab指定的網址與安裝最新的版本不過我通常都把連線的網址都在佈署完成之後再另外設定所以我如果要安裝8.8.9的版本，那指令應該如下：\n$ sudo apt-get install gitlab-ee=8.8.9-ee.0\n安裝完成後再去更改external_url就好，更改路徑如下：\n/etc/gitlab/gitlab.rb\n設置連線配置\nexternal_url &#x27;http://127.0.0.1&#x27;\n最後再重新設定配置就完成了\n$ sudo gitlab-ctl reconfigure\n通常第一次登入會讓你重新設置root的密碼修改完再登入你就可以看到gitlab的歡迎畫面了\n\n\n如果只需要英文版本的那你看到這裡就行了接下來講講如何佈署成中文\ngitlab中文化第一步先用git clone整個中文開發項目\n$ git clone https://gitlab.com/larryli/gitlab.git\nclone下來之後就可以開始我們的中文化大業了\n# 先進入clone下來的項目中$ cd gitlab# 可以先看看所有版本的開發分支# git tag\n比對所有對應的本版分支\n$ sudo git diff v8.8.0..8.8.5.zh1 &gt; /tmp/8.8.diff\n停掉gitlab運行\n$ sudo gitlab-ctl stop\n應用中文化補丁\n$ sudo patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; /tmp/8.8.diff\n接下來就一直不斷enter到補丁完成，重新啟動gitlab\n$ sudo gitlab-ctl start\n重新登入之後就可看到熟悉的中文化介面\n","categories":["gitlab"],"tags":["佈署","gitlab","中文化"]},{"title":"Hello World","url":"/2018/03/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"安裝OpenJDK","url":"/2019/03/10/java-installopenjdk/","content":"安裝OpenJDK安裝預設版本OpenJDK\n$ sudo apt-get update$ sudo apt-get install default-jdk\n安裝指定版本OpenJDK\n$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk\n安裝指定版本OpenJRE\n$ sudo apt-get update$ sudo apt-get install openjdk-8-jre\n\n設定系統 Java 版本先查看當前有哪些版本可供設定\n$ update-alternatives --query java#或者$ update-alternatives --display java\n設定版本\n$ sudo update-alternatives --config java\n\n設置Java環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$JAVA_HOME/bin","categories":["java"],"tags":["java","jdk"]},{"title":"Jenkins搭建","url":"/2018/03/24/jenkins-install/","content":"要搭建jenkins需要安裝JDK，以下提供簡易安裝方式\n安裝OpenJDK安裝OpenJDK\n$ sudo apt-get update$ sudo apt-get install default-jdk\n\n\n\njenkins佈署jenkins官網\n基本上按照官方提供的方式安裝即可，首先添加套件金鑰\n$ wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -\n添加套件來源列表\n$ sudo sh -c &#x27;echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#x27;\n最後進行安裝\n$ sudo apt-get update$ sudo apt-get install jenkins\n修改連線配置(&#x2F;etc&#x2F;default&#x2F;jenkins)，基本上默認端口為8080\nHTTP_PORT=8080\n啟動腳本路徑(&#x2F;etc&#x2F;init.d&#x2F;jenkins)\n$ sudo bash /etc/init.d/jenkins  &#123;start|stop|status|restart|force-reload&#125;\n另外也可以這樣\n$ sudo service jenkins  &#123;start|stop|status|restart|force-reload&#125;\n啟動之後需要設置初始密碼\n$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword9b4e46e0c33e4e99b9bbc916a7adccac\n輸入初始密碼\n\n選擇預設插件集合\n\n等待初始化完成\n\n最後再建立管理者帳號就大功告成了\n","categories":["jenkins"],"tags":["佈署","jenkins"]},{"title":"Jenkins + Gitlab + Maven + JDK 設定","url":"/2018/03/29/jenkins-setting/","content":"在jenkins安裝好後還需要一些進一步的設定，才能讓其他工具好好運作，下面我們就開始做完這些設定\n\n\n進入jenkins設定\n\n\n進入Global Tool Configuration\n\n\n設置你的JDK安裝路徑\n\n\n設置你的GIT安裝路徑\n\n\n設置你的MAVEN安裝路徑\n\n\n接下來生成SSL金鑰，如果已經有了可以跳過這一步\n$ ssh-keygen -t rsa -C\n接下來去Credentials設置SSL連線配置\n\n\n最後我們要去把jenkins的系統權限加入到root裡面，不然他在跑shell會有權限問題\n將jenkins帳號加入root群組中\n$ sudo gpasswd -a root jenkins\n修改jenkins文件\n$ sudo nano /etc/default/jenkins\n修改文件中這兩行\nJENKINS_USER=rootJENKINS_GROUP=root\n完成這些設定就大功告成啦!\n","categories":["jenkins"],"tags":["gitlab","jdk","jenkins","maven"]},{"title":"解決Jenkins執行sudo命令出現錯誤","url":"/2019/03/10/jenkins-sudoerror/","content":"我們在使用jenkins部屬任務的時候常常需要使用到腳本，如果在腳本中使用到了sudo這個令命時，有可能會產生以下錯誤：\nsudo: no tty present and no askpass program specified\n\n解决方式：在jenkins host server上執行以下命令：\n$ sudo visudo\n在末尾加入：\njenkins ALL=(ALL) NOPASSWD: ALL\nCtrl+O 存檔(ps.存檔的時候副檔名不要加入.tmp，這樣即可覆蓋原來的檔案)Ctrl+X 離開\n最後重啟jenkins\n$ sudo bash /etc/init.d/jenkins restart#另外也可以這樣$ sudo service jenkins restart\n\n最後再重新建構一次任務即可\n","categories":["jenkins"],"tags":["jenkins","error"]},{"title":"Jenkins + Gitlab + Tomcat 自動化部署","url":"/2018/03/29/jenkins-work/","content":"前面做這麼多都是為了現在做準備，假設我們的workflow\n程式更新代碼至gitlab -&gt; 企劃或者anyone按個按鍵 -&gt; jenkins自動幫你完成專案更新代碼並重新佈署\n這樣我們可以減少人力去處理這些雜事更能專心再業務處理的需求上下面就來看看怎麼完成這些設定\n\n\n新增作業\n\n\n填好項目名稱並選擇free-style\n\n\n這步驟是讓你自訂workspace路徑，不設定就會是預設項目路徑\n\n\n填入你的項目git來源，並使用之前設定好的ssl連線憑證\n\n\n選擇maven作為項目打包工具並填入相關腳本指令之後在執行shell script把maven打包好的檔案轉移至tomcat目錄底下在啟動tomcat\n\n\n儲存好相關設置之後再執行建置\n\n\n一切就自動化部署完成了!\n","categories":["jenkins"],"tags":["gitlab","jenkins","tomcat"]},{"title":"Kubernetes ConfigMap 使用指南","url":"/2025/10/25/kubernetes-configmap-intro/","content":"Kubernetes ConfigMap 使用指南什麼是 ConfigMap？Kubernetes ConfigMap 是一個 API 物件，用於存儲非敏感的配置資料，以鍵值對的形式存在。ConfigMap 允許您將配置從容器映像中分離出來，使應用程式更具可移植性和靈活性。\nConfigMap 的主要功能：\n配置分離：將應用程式配置與程式碼分離\n環境管理：支援不同環境的配置管理\n動態更新：支援運行時配置更新\n多種掛載方式：可作為環境變數、檔案或目錄掛載\n\n為什麼使用 ConfigMap？相較於將配置硬編碼在應用程式中，ConfigMap 提供了更好的配置管理方式：\n\n靈活性：無需重新構建映像就能改變配置\n可重用性：同一個 ConfigMap 可被多個 Pod 使用\n版本控制：配置變更可以被追蹤和管理\n環境一致性：確保不同環境使用正確的配置\n\n\n\n\nConfigMap 基本配置基本 ConfigMap 範例apiVersion: v1kind: ConfigMapmetadata:  name: dockertest-config  namespace: dockertest-namespace  labels:    app: dockertestdata:  # 應用程式配置  CUSTOM_VALUE: &quot;configmap_version&quot;  LOG_LEVEL: &quot;INFO&quot;  MAX_CONNECTIONS: &quot;100&quot;  FEATURE_ENABLED: &quot;true&quot;    # 資料庫配置  DB_HOST: &quot;database.example.com&quot;  DB_PORT: &quot;5432&quot;  DB_NAME: &quot;myapp&quot;    # 快取配置  REDIS_HOST: &quot;redis.example.com&quot;  REDIS_PORT: &quot;6379&quot;\n\n包含檔案內容的 ConfigMapapiVersion: v1kind: ConfigMapmetadata:  name: app-config-files  namespace: dockertest-namespacedata:  # 配置檔案內容  application.properties: |    app.name=MyApplication    app.version=1.0.0    server.port=8080    logging.level.root=INFO      nginx.conf: |    server &#123;        listen 80;        server_name localhost;        location / &#123;            root /usr/share/nginx/html;            index index.html;        &#125;    &#125;      # JSON 格式配置  config.json: |    &#123;      &quot;database&quot;: &#123;        &quot;host&quot;: &quot;localhost&quot;,        &quot;port&quot;: 5432,        &quot;name&quot;: &quot;myapp&quot;      &#125;,      &quot;features&quot;: &#123;        &quot;enableLogging&quot;: true,        &quot;maxRetries&quot;: 3      &#125;    &#125;\n\n在 Pod 中使用 ConfigMap方法一：作為環境變數apiVersion: apps/v1kind: Deploymentmetadata:  name: dockertest-deployment  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: dockertest  template:    metadata:      labels:        app: dockertest    spec:      containers:      - name: dockertest        image: docker.io/pcion123/tinydocker:0.0.10        env:        # 引用整個 ConfigMap        - name: CUSTOM_VALUE          valueFrom:            configMapKeyRef:              name: dockertest-config              key: CUSTOM_VALUE        - name: LOG_LEVEL          valueFrom:            configMapKeyRef:              name: dockertest-config              key: LOG_LEVEL        # 引用多個鍵值        envFrom:        - configMapRef:            name: dockertest-config\n\n\n\n方法二：作為檔案掛載apiVersion: apps/v1kind: Deploymentmetadata:  name: dockertest-deployment  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: dockertest  template:    metadata:      labels:        app: dockertest    spec:      containers:      - name: dockertest        image: docker.io/pcion123/tinydocker:0.0.10        volumeMounts:        # 掛載整個 ConfigMap 為目錄        - name: config-volume          mountPath: /etc/config        # 掛載特定檔案到指定位置        - name: nginx-config          mountPath: /etc/nginx/nginx.conf          subPath: nginx.conf      volumes:      - name: config-volume        configMap:          name: dockertest-config      - name: nginx-config        configMap:          name: dockertest-config          items:          - key: nginx.conf            path: nginx.conf\n\n\n\n方法三：混合使用apiVersion: apps/v1kind: Deploymentmetadata:  name: dockertest-deployment  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: dockertest  template:    metadata:      labels:        app: dockertest    spec:      containers:      - name: dockertest        image: docker.io/pcion123/tinydocker:0.0.10        env:        # 引用整個 ConfigMap        - name: CUSTOM_VALUE          valueFrom:            configMapKeyRef:              name: dockertest-config              key: CUSTOM_VALUE        - name: LOG_LEVEL          valueFrom:            configMapKeyRef:              name: dockertest-config              key: LOG_LEVEL        # 引用多個鍵值        envFrom:        - configMapRef:            name: dockertest-config        volumeMounts:        # 掛載整個 ConfigMap 為目錄        - name: config-volume          mountPath: /etc/config        # 掛載特定檔案到指定位置        - name: nginx-config          mountPath: /etc/nginx/nginx.conf          subPath: nginx.conf      volumes:      - name: config-volume        configMap:          name: dockertest-config      - name: nginx-config        configMap:          name: dockertest-config          items:          - key: nginx.conf            path: nginx.conf\n\n建立和管理 ConfigMap使用 kubectl 指令建立# 從字面值建立kubectl create configmap my-config \\  --from-literal=key1=value1 \\  --from-literal=key2=value2 \\  -n dockertest-namespace# 從檔案建立kubectl create configmap file-config \\  --from-file=application.properties \\  --from-file=config.json \\  -n dockertest-namespace# 從目錄建立kubectl create configmap dir-config \\  --from-file=./config-directory/ \\  -n dockertest-namespace# 從環境檔案建立kubectl create configmap env-config \\  --from-env-file=.env \\  -n dockertest-namespace\n\n管理指令# 查看 ConfigMap 列表kubectl get configmaps -n dockertest-namespace# 查看 ConfigMap 詳細內容kubectl describe configmap dockertest-config -n dockertest-namespace# 查看 ConfigMap 的 YAML 格式kubectl get configmap dockertest-config -n dockertest-namespace -o yaml# 編輯 ConfigMapkubectl edit configmap dockertest-config -n dockertest-namespace# 刪除 ConfigMapkubectl delete configmap dockertest-config -n dockertest-namespace\n\n更新 ConfigMap# 方法一：重新應用 YAML 檔案kubectl apply -f configmap.yaml# 方法二：使用 patch 更新特定鍵值kubectl patch configmap dockertest-config -n dockertest-namespace \\  --type merge -p &#x27;&#123;&quot;data&quot;:&#123;&quot;NEW_KEY&quot;:&quot;new_value&quot;&#125;&#125;&#x27;# 方法三：替換整個 ConfigMapkubectl replace -f updated-configmap.yaml\n\n實際應用範例範例一：Spring Boot 應用程式配置apiVersion: v1kind: ConfigMapmetadata:  name: spring-app-config  namespace: dockertest-namespacedata:  # Spring Boot 配置  SPRING_PROFILES_ACTIVE: &quot;production&quot;  SERVER_PORT: &quot;8080&quot;  LOGGING_LEVEL_ROOT: &quot;INFO&quot;  LOGGING_LEVEL_COM_EXAMPLE: &quot;DEBUG&quot;    # 資料庫配置  SPRING_DATASOURCE_URL: &quot;jdbc:postgresql://db:5432/myapp&quot;  SPRING_DATASOURCE_USERNAME: &quot;appuser&quot;  SPRING_DATASOURCE_DRIVERCLASSNAME: &quot;org.postgresql.Driver&quot;    # JVM 配置  JAVA_OPTS: &quot;-Xmx512m -Xms256m -Djava.awt.headless=true&quot;---apiVersion: apps/v1kind: Deploymentmetadata:  name: spring-app  namespace: dockertest-namespacespec:  replicas: 2  selector:    matchLabels:      app: spring-app  template:    metadata:      labels:        app: spring-app    spec:      containers:      - name: spring-app        image: docker.io/pcion123/tinydocker:0.0.10        envFrom:        - configMapRef:            name: spring-app-config        ports:        - containerPort: 8080\n\n範例二：多環境配置管理# 開發環境 ConfigMapapiVersion: v1kind: ConfigMapmetadata:  name: app-config-dev  namespace: developmentdata:  ENVIRONMENT: &quot;development&quot;  LOG_LEVEL: &quot;DEBUG&quot;  DB_HOST: &quot;dev-database&quot;  CACHE_ENABLED: &quot;false&quot;---# 生產環境 ConfigMapapiVersion: v1kind: ConfigMapmetadata:  name: app-config-prod  namespace: productiondata:  ENVIRONMENT: &quot;production&quot;  LOG_LEVEL: &quot;WARN&quot;  DB_HOST: &quot;prod-database&quot;  CACHE_ENABLED: &quot;true&quot;\n\n最佳實務建議配置管理\n命名規範：使用清晰、一致的 ConfigMap 命名\n環境分離：為不同環境建立獨立的 ConfigMap\n版本控制：將 ConfigMap 定義納入版本控制系統\n文檔記錄：詳細記錄每個配置項的用途和格式\n\n安全性考量\n敏感資料：將密碼等敏感資料存儲在 Secret 中，而非 ConfigMap\n存取控制：使用 RBAC 控制 ConfigMap 的存取權限\n最小權限：只授予應用程式所需的最小配置存取權限\n定期審核：定期檢查和清理不再使用的 ConfigMap\n\n效能和可靠性\n大小限制：單個 ConfigMap 不應超過 1MB\n變更影響：了解 ConfigMap 變更對運行中 Pod 的影響\n自動重啟：考慮使用工具自動重啟使用更新配置的 Pod\n配置驗證：在應用配置前驗證配置的正確性\n\n監控和維護\n配置追蹤：追蹤配置變更的歷史和影響\n健康檢查：確保應用程式能正確讀取和使用配置\n備份策略：定期備份重要的 ConfigMap\n清理策略：定期清理不再使用的 ConfigMap\n\n疑難排解常見問題1. Pod 無法讀取 ConfigMap# 檢查 ConfigMap 是否存在kubectl get configmap dockertest-config -n dockertest-namespace# 檢查 Pod 配置kubectl describe pod &lt;pod-name&gt; -n dockertest-namespace# 查看 Pod 日誌kubectl logs &lt;pod-name&gt; -n dockertest-namespace\n\n2. 配置更新後 Pod 未重啟# 手動重啟 Deploymentkubectl rollout restart deployment dockertest-deployment -n dockertest-namespace# 查看重啟狀態kubectl rollout status deployment dockertest-deployment -n dockertest-namespace\n\n3. 環境變數未正確載入# 進入 Pod 檢查環境變數kubectl exec -it &lt;pod-name&gt; -n dockertest-namespace -- env | grep CUSTOM_VALUE# 檢查 ConfigMap 內容kubectl get configmap dockertest-config -n dockertest-namespace -o yaml\n\n透過正確使用 ConfigMap，您可以實現靈活的配置管理，讓應用程式更容易在不同環境間移植和部署，同時保持配置的一致性和可維護性。\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes 控制元件介紹","url":"/2025/10/04/kubernetes-controller-intro/","content":"Kubernetes 控制元件介紹在 Kubernetes 中，我們需要控制平面 (Control Plane) 來管理 Node 的運行狀態。接下來我們將介紹 Node 是如何被管理的，以及各個控制元件的功能。\n整體架構概述Kubernetes 採用 Master-Worker 架構模式：\n\nControl Plane (Master): 負責管理整個叢集的決策和控制\nWorker Nodes: 負責執行實際的應用程式工作負載\n\n\n\n\n\n\nNode ComponentsNode Components 是每個 Worker Node 必須具備的核心元件：\n\nContainer Runtime: 負責管理容器的生命週期，包括容器的建立、執行和銷毀\nkubelet: 作為 Node 的代理程式，負責建立 Pod 並維護容器的健康狀態\nkube-proxy: 負責處理 Node 的網路代理功能，實現服務發現和負載平衡\n\nControl Plane Components控制平面負責管理整個 Kubernetes 叢集中所有的 Node Components。以下是控制平面的核心元件：\n\nkube-api-server: 作為 Kubernetes API 的前端，負責處理來自客戶端的請求，經過驗證和授權後，將請求轉發給對應的元件\nkube-scheduler: 負責將 Pod 調度到適合的 Node 上執行，會根據資源可用性、硬體需求等條件來選擇最佳的 Node\nkube-controller-manager: 執行各種控制器，負責監控 Kubernetes 叢集的狀態變化並確保達到期望狀態\netcd: 分散式的 key-value 儲存系統，用來儲存 Kubernetes 叢集的所有配置資料和狀態資訊\ncloud-controller-manager: 負責與雲端服務提供商進行整合的元件，它可以幫助 Kubernetes 連接公有雲平台，使用雲端服務的 API 來管理雲端資源\n\n\n提示etcd 採用分散式架構設計，因此在一個 Kubernetes 叢集中可以同時部署多個 Control Plane 元件來實現高可用性\n\n\n提示cloud-controller-manager 僅在雲端環境中才會部署，如果 Kubernetes 叢集運行在本地環境則不會包含此元件（例如：minikube）\n\n為了確保服務的高可用性，生產環境的 Kubernetes 通常會部署兩個以上的 Control Plane 節點。\n元件間的通訊機制所有元件之間的通訊都必須透過 kube-api-server 進行，它是整個 Kubernetes 架構的核心通訊樞紐：\n\nkubelet 透過 API Server 回報 Node 和 Pod 的狀態\nController Manager 透過 API Server 監控叢集狀態\nScheduler 透過 API Server 獲取調度資訊並做出調度決策\n所有配置和狀態資料都儲存在 etcd 中，只有 API Server 能直接存取\n\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes 核心元件介紹","url":"/2025/09/28/kubernetes-core-intro/","content":"Kubernetes 核心元件介紹架構總覽\n\n上圖展示了 Kubernetes 完整架構，包含控制平面、工作節點、服務層和配置管理等核心元件及其互動關係\n\n\n\nPodKubernetes 中的最小運行單位\n\n每個 Pod 都會被分配一個唯一的虛擬 IP 位址\nContainer: Pod 內運行的應用程式容器，雖然每個 Pod 可以運行多個容器，但通常建議只運行一個主要容器\n\nNodeKubernetes 叢集的工作節點\n\n可以是實體機器或虛擬機器\n多個 Node 組成 Kubernetes 叢集，提供運算資源\n\nService提供穩定的網路端點\n\n解決 Pod 重啟時 IP 位址變動的問題\n提供固定的 IP 位址和 DNS 名稱，作為 Pod 群組的存取入口\n分為兩種類型：\n內部 Service: 僅供叢集內部通訊使用\n外部 Service: 允許外部流量存取\n\n\n\nIngressHTTP&#x2F;HTTPS 路由管理\n\n提供域名對應服務，讓外部用戶能透過網域名稱存取 Service\n支援 SSL&#x2F;TLS 憑證管理和負載平衡\n\nConfigMap應用程式配置管理\n\n儲存非敏感的配置資料（如設定檔、環境變數）\n避免因配置變更而重新建置映像檔，減少部署停機時間\n支援熱更新配置\n\n\n警告ConfigMap 以明文方式儲存內容，請勿存放敏感資料\n\nSecret敏感資料安全儲存\n\n專門用於儲存機敏資料（如密碼、API 金鑰、憑證）\n資料以 Base64 編碼格式儲存\n提供比 ConfigMap 更高的安全性\n\n\n註解Secret 使用 Base64 編碼儲存資料，並可與 Pod 安全地共享\n\nVolumes持久化資料儲存\n\n解決容器重啟時資料遺失的問題\n提供多種儲存類型（本機儲存、網路儲存、雲端儲存）\n確保重要資料在 Pod 生命週期外持續保存\n\nDeployment無狀態應用程式的部署管理\n\n管理 Pod 的部署、更新和擴縮容\n提供聲明式更新，確保應用程式的期望狀態\n支援滾動更新（Rolling Update）和回滾功能\n適用於無狀態的應用程式，如網頁伺服器、API 服務\n主要功能：\n副本管理: 確保指定數量的 Pod 副本正常運行\n自動修復: 當 Pod 異常時自動重新建立\n版本控制: 追蹤部署歷史，支援快速回滾\n零停機部署: 透過滾動更新實現無中斷服務更新\n\n\n\n\n提示Deployment 是部署無狀態應用程式的首選方式，提供了強大的生命週期管理功能\n\nStatefulSet有狀態應用程式的部署管理\n\n專門用於管理有狀態的應用程式，如資料庫、訊息佇列\n為每個 Pod 提供穩定且唯一的網路識別符\n保證 Pod 的有序部署、擴縮容和終止\n提供持久化儲存與 Pod 的穩定綁定關係\n主要特色：\n穩定的網路識別: 每個 Pod 都有固定的主機名稱（如 pod-0, pod-1）\n有序部署: Pod 按照順序建立，確保前一個 Pod 就緒後才建立下一個\n持久儲存: 每個 Pod 都有專屬的持久化儲存卷\n有序終止: 刪除時按照相反順序進行，確保資料完整性\n\n\n\n\n重要提示StatefulSet 適用於需要穩定儲存和網路識別的應用程式，如 MySQL、MongoDB、Kafka 等\n\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes Deployment 使用指南","url":"/2025/10/11/kubernetes-deployment/","content":"Kubernetes Deployment 使用指南什麼是 Deployment？Kubernetes Deployment 是一個 API 物件，用於管理應用程式的宣告式部署和更新。Deployment 提供了對 Pod 和 ReplicaSet 的管理功能，確保應用程式能夠穩定運行並支援無縫更新。\nDeployment 的主要功能：\n副本管理：維護指定數量的 Pod 副本，確保服務的高可用性\n滾動更新：支援零停機時間的應用程式更新\n版本回滾：快速回滾到先前的應用程式版本\n擴縮容：根據需求動態調整 Pod 的數量\n\n為什麼使用 Deployment？相較於直接管理 Pod 或 ReplicaSet，Deployment 提供了更高層次的管理抽象：\n\n宣告式管理：只需描述期望狀態，Kubernetes 會自動達成目標\n更新策略：內建滾動更新機制，避免服務中斷\n版本控制：保留部署歷史，支援快速回滾\n\n\n\n\nDeployment 範例配置以下是一個完整的 Deployment 配置範例，展示了如何部署一個 Java Spring Boot 應用程式：\napiVersion: apps/v1kind: Deploymentmetadata:  name: dockertest-deployment  namespace: dockertest-namespace  labels:    app: dockertest    version: v0.0.8spec:  replicas: 1  selector:    matchLabels:      app: dockertest  template:    metadata:      labels:        app: dockertest        version: v0.0.8    spec:      containers:      - name: dockertest        image: docker.io/pcion123/tinydocker:0.0.8        imagePullPolicy: Always        ports:        - containerPort: 8080        env:        - name: JAVA_OPTS          value: &quot;-Xmx512m -Xms256m -Djava.awt.headless=true -Dspring.profiles.active=dev&quot;        - name: TZ          value: &quot;Asia/Taipei&quot;        livenessProbe:          httpGet:            path: /actuator/health            port: 8080          initialDelaySeconds: 60          periodSeconds: 30          timeoutSeconds: 10          failureThreshold: 3        readinessProbe:          httpGet:            path: /actuator/health/readiness            port: 8080          initialDelaySeconds: 30          periodSeconds: 10          timeoutSeconds: 5          failureThreshold: 3      imagePullSecrets:        - name: regcred\n\n配置詳解Metadata 區段\nname: Deployment 的名稱，在同一個 namespace 中必須唯一\nnamespace: 指定部署的命名空間\nlabels: 用於識別和分組資源的標籤\n\nSpec 區段\nreplicas: 指定要運行的 Pod 副本數量\nselector: 用於選擇管理哪些 Pod 的標籤選擇器\ntemplate: Pod 模板，定義了 Pod 的規格\n\nContainer 配置\nimage: 容器映像檔位置\nimagePullPolicy: 映像檔拉取策略，Always 表示每次都會重新拉取\nports: 容器對外暴露的連接埠\nenv: 環境變數設定\nimagePullSecrets: 指定用於從私有容器註冊表拉取映像檔的 Secret 資源。當容器映像檔存放在需要身份驗證的私有倉庫時（如 Docker Hub 私有倉庫、Azure Container Registry、Amazon ECR 等），Kubernetes 需要相應的認證資訊才能成功拉取映像檔。此配置引用預先建立的 Kubernetes Secret 物件，該 Secret 包含了註冊表的登入憑證。\n\n\n關於如何拉取 image 的詳細說明，請參考之前的文章\n健康檢查配置Liveness Probe（存活探針）用於檢查容器是否仍在運行，如果檢查失敗，Kubernetes 會重啟容器。\nReadiness Probe（就緒探針）用於檢查容器是否準備好接收流量，如果檢查失敗，容器會從 Service 的端點中移除。\n常用操作指令部署應用程式kubectl apply -f dockertest-deployment-v0.0.8.yaml\n\n\n\n查看 Deployment 狀態kubectl get deployments -n dockertest-namespace\n\n\n\n查看 Deployment 詳細資訊kubectl describe deployment dockertest-deployment -n dockertest-namespace\n\n\n\n擴縮容操作# 擴展到 3 個副本kubectl scale deployment dockertest-deployment --replicas=3 -n dockertest-namespace\n\n\n\n更新應用程式# 更新映像檔版本（從 0.0.10 更新到 0.0.11）kubectl set image deployment/dockertest-deployment dockertest=docker.io/pcion123/tinydocker:0.0.11 -n dockertest-namespace\n\n\n\n查看更新狀態kubectl rollout status deployment/dockertest-deployment -n dockertest-namespace\n\n\n\n回滾到上一個版本kubectl rollout undo deployment/dockertest-deployment -n dockertest-namespace\n\n\n\n查看部署歷史kubectl rollout history deployment/dockertest-deployment -n dockertest-namespace\n\n\n\n查看 Pod 狀態kubectl get pods -n dockertest-namespace -l app=dockertest\n\n\n\n最佳實務建議\n設定適當的資源限制: 為容器設定 CPU 和記憶體的 requests 和 limits\n配置健康檢查: 務必設定 liveness 和 readiness probe 以確保應用程式的穩定性\n使用標籤管理: 善用標籤來組織和管理不同的資源\n版本控制: 使用具體的映像檔標籤而非 latest\n命名空間隔離: 使用不同的命名空間來隔離不同環境的應用程式\n\n透過這些配置和操作，您可以有效地管理 Kubernetes 中的應用程式部署，確保服務的高可用性和穩定性。\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes Image 拉取指南","url":"/2025/10/11/kubernetes-image-pull/","content":"Kubernetes Image 拉取指南什麼是容器映像拉取？在 Kubernetes 中，Pod 需要使用容器映像來啟動容器。根據映像的來源和存取方式不同，Kubernetes 提供了多種映像拉取策略。了解這些不同的拉取方式對於有效管理應用程式部署至關重要。\n映像拉取的主要場景：\n本地映像：使用本地構建並載入到節點的映像\n公開倉庫：從 Docker Hub 等公開倉庫拉取映像\n私有倉庫：從需要身份驗證的私有倉庫拉取映像\n企業倉庫：從組織內部的私有映像倉庫拉取映像\n\n為什麼需要了解不同的拉取方式？根據不同的使用場景，選擇合適的映像拉取方式可以：\n\n提升效率：減少不必要的網路傳輸和下載時間\n增強安全性：保護私有映像不被未授權存取\n降低成本：避免重複拉取相同的映像\n\n\n\n\n方式一：本地 Docker 映像直接引用概述當您在本地環境（如 Minikube、Docker Desktop）開發時，可以直接使用本地構建的 Docker 映像，無需推送到遠端倉庫。\n使用場景\n開發和測試階段\n本地 Kubernetes 環境（Minikube、Kind）\n不希望將映像推送到外部倉庫的情況\n\n實作步驟1. 確保 Docker 環境與 Kubernetes 共享在 Minikube 中：\n# 設定 Docker 環境指向 Minikubeeval $(minikube docker-env)# 或在 Windows PowerShell 中minikube docker-env | Invoke-Expression# 驗證已切換到 Minikube Docker 環境docker context ls# 或者檢查 Docker Hostecho $DOCKER_HOST# Minikube 環境會顯示類似：tcp://192.168.49.2:2376\n\n\n\n切回原本的 Docker 環境：\n# 在 Linux/macOS 中eval $(minikube docker-env -u)# 或在 Windows PowerShell 中minikube docker-env -u | Invoke-Expression# 或者直接重新啟動終端機會話# 新的終端會自動使用本地 Docker 環境\n\n\n\n在 Docker Desktop 中：Docker Desktop 的 Kubernetes 會自動共享本地 Docker 映像。\n2. 構建本地映像# 構建 Docker 映像docker build -t my-local-app:latest .# 驗證映像已建立docker images | grep my-local-app\n\n3. 在 Kubernetes 中使用本地映像apiVersion: apps/v1kind: Deploymentmetadata:  name: local-app-deployment  namespace: defaultspec:  replicas: 1  selector:    matchLabels:      app: local-app  template:    metadata:      labels:        app: local-app    spec:      containers:      - name: app        image: my-local-app:latest        imagePullPolicy: Never  # 關鍵設定：不從遠端拉取        ports:        - containerPort: 8080\n\n4. 部署應用程式kubectl apply -f local-deployment.yaml\n\n重要注意事項\nimagePullPolicy: 必須設定為 Never 或 IfNotPresent\n映像標籤: 建議使用具體的標籤而非 latest\n節點限制: 映像只存在於特定節點上\nDocker 環境切換: 使用 minikube docker-env 後記得切回原本環境\n使用 eval $(minikube docker-env -u) 來取消設定\n或重新啟動終端機會話\n\n\n\nDocker 環境管理# 檢查當前 Docker 環境和主機echo $DOCKER_HOST# 本地：通常為空或顯示 unix:///var/run/docker.sock# Minikube：顯示 tcp://192.168.49.2:2376 (或類似的 IP)# 查看 Docker 上下文docker context ls# 列出 Docker 映像（確認在正確的環境中）docker images# 如果需要在不同環境間切換：# 切換到 Minikubeeval $(minikube docker-env)echo &quot;當前 Docker Host: $DOCKER_HOST&quot;# 切換回本地eval $(minikube docker-env -u)echo &quot;當前 Docker Host: $DOCKER_HOST&quot;\n\n\n方式二：拉取 Docker Hub 公開倉庫映像概述從 Docker Hub 等公開倉庫拉取映像是最常見的方式，適用於使用開源軟體或公開可用的應用程式映像。\n使用場景\n使用官方映像（如 nginx、redis、mysql）\n使用開源專案的公開映像\n生產環境中的標準化映像\n\n實作步驟1. 基本公開映像使用範例apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  namespace: defaultspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.21-alpine  # Docker Hub 官方映像        imagePullPolicy: Always   # 總是拉取最新版本        ports:        - containerPort: 80\n\n2. 進階公開映像配置範例apiVersion: apps/v1kind: Deploymentmetadata:  name: tomcat-deployment  namespace: defaultspec:  replicas: 1  selector:    matchLabels:      app: tomcat  template:    metadata:      labels:        app: tomcat    spec:      containers:      - name: tomcat        image: tomcat:10.1-jdk17        imagePullPolicy: IfNotPresent  # 如果本地不存在才拉取        ports:        - containerPort: 8080        command: [&quot;/bin/sh&quot;,&quot;-c&quot;]        args:          - cp -r /usr/local/tomcat/webapps.dist/ROOT /usr/local/tomcat/webapps/ &amp;&amp; exec catalina.sh run        readinessProbe:          httpGet:            path: /            port: 8080          initialDelaySeconds: 10          periodSeconds: 5\n\n3. 部署應用程式# 部署基本的 Nginx 應用kubectl apply -f nginx-deployment.yaml# 部署進階的 Tomcat 應用kubectl apply -f tomcat-deployment.yaml# 查看部署狀態kubectl get deploymentskubectl get pods\n\nImagePullPolicy 選項說明\nAlways: 每次都重新拉取映像\nIfNotPresent: 本地不存在時才拉取（預設值）\nNever: 絕不拉取，只使用本地映像\n\n\n方式三：拉取 Docker Hub 私有倉庫映像概述當使用私有倉庫中的映像時，需要提供身份驗證資訊。Kubernetes 使用 Image Pull Secret 來安全地存儲這些憑證。\n使用場景\n使用組織的私有映像\n商業軟體的私有映像\n包含敏感資訊的應用程式映像\n\n實作步驟1. 建立 Docker Registry Secret為了讓 Kubernetes 能夠從 Docker Hub 私有倉庫拉取映像檔，需要建立包含認證資訊的 Secret 資源：\nkubectl create secret docker-registry regcred \\  --docker-server=https://index.docker.io/v1/ \\  --docker-username=&lt;username&gt; \\  --docker-password=&lt;password&gt; \\  --docker-email=&lt;mail&gt; \\  --namespace=&lt;namespace&gt;\n\n參數說明：\n\nregcred：Secret 的名稱，可以自行定義\n--docker-server：Docker Hub 的伺服器地址，固定為 https://index.docker.io/v1/\n--docker-username：您的 Docker Hub 使用者名稱\n--docker-password：建議使用 Personal Access Token (PAT) 而非密碼\n--namespace：指定 Secret 建立的命名空間\n\n\n關於如何獲取 Docker Hub Personal Access Token 的詳細說明，請參考之前的文章\n重要提醒：\n\n出於安全考量，強烈建議使用 Personal Access Token (PAT) 而非帳戶密碼\n--docker-email 參數為可選，現代 Docker 倉庫通常不需要此參數\nSecret 必須建立在與 Pod 相同的命名空間中才能使用\n\n2. 在 Deployment 中使用私有映像apiVersion: apps/v1kind: Deploymentmetadata:  name: k8s-deployment  namespace: k8s-namespacespec:  replicas: 1  selector:    matchLabels:      app: k8s-app  template:    metadata:      labels:        app: k8s-app    spec:      containers:      - name: k8s-app        image: &lt;username&gt;/&lt;repo-name&gt;:latest  # 私有倉庫映像        imagePullPolicy: Always        ports:        - containerPort: 8080      imagePullSecrets:  # 指定用於身份驗證的 Secret      - name: regcred\n\n3. 使用 ServiceAccount 自動套用 SecretapiVersion: v1kind: ServiceAccountmetadata:  name: k8s-sa  namespace: k8s-namespaceimagePullSecrets:- name: regcred---apiVersion: apps/v1kind: Deploymentmetadata:  name: k8s-deployment  namespace: k8s-namespacespec:  replicas: 1  selector:    matchLabels:      app: k8s-app  template:    metadata:      labels:        app: k8s-app    spec:      serviceAccountName: k8s-sa  # 使用 ServiceAccount      containers:      - name: k8s-app        image: &lt;username&gt;/&lt;repo-name&gt;:latest  # 私有倉庫映像        imagePullPolicy: Always        ports:        - containerPort: 8080\n\n不同私有倉庫的設定AWS ECRkubectl create secret docker-registry ecr-secret \\  --docker-server=&lt;account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com \\  --docker-username=AWS \\  --docker-password=$(aws ecr get-login-password) \\  --namespace=&lt;namespace&gt;\n\nAzure ACRkubectl create secret docker-registry acr-secret \\  --docker-server=&lt;registry-name&gt;.azurecr.io \\  --docker-username=&lt;username&gt; \\  --docker-password=&lt;password&gt; \\  --namespace=&lt;namespace&gt;\n\nGoogle GCRkubectl create secret docker-registry gcr-secret \\  --docker-server=gcr.io \\  --docker-username=_json_key \\  --docker-password=&quot;$(cat key.json)&quot; \\  --namespace=&lt;namespace&gt;\n\n常用管理指令查看映像拉取狀態# 查看 Pod 狀態kubectl get pods -n &lt;namespace&gt;# 查看 Pod 詳細資訊（包含映像拉取事件）kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;# 查看映像拉取相關的事件kubectl get events --field-selector reason=Pulling -n &lt;namespace&gt;\n\n管理 Image Pull Secrets# 查看 Secret 列表kubectl get secrets -n &lt;namespace&gt;# 查看 Secret 詳細資訊kubectl describe secret &lt;secret-name&gt; -n &lt;namespace&gt;# 刪除 Secretkubectl delete secret &lt;secret-name&gt; -n &lt;namespace&gt;\n\n手動拉取映像進行測試# 在節點上手動拉取映像docker pull &lt;image-name&gt;# 檢查映像是否存在docker images | grep &lt;image-name&gt;\n\n疑難排解常見問題與解決方案1. ImagePullBackOff 錯誤# 檢查 Pod 事件kubectl describe pod &lt;pod-name&gt;# 常見原因：# - 映像名稱錯誤# - 網路連線問題# - 身份驗證失敗# - 映像不存在\n\n2. 本地映像無法拉取\n確認 imagePullPolicy 設定為 Never 或 IfNotPresent\n檢查映像是否存在於正確的節點上\n在 Minikube 中確認 Docker 環境設定正確\nDocker 環境問題：確認是否在正確的 Docker 環境中# 檢查當前 Docker 環境（更準確的方法）echo $DOCKER_HOST# 本地環境：通常為空或 unix:///var/run/docker.sock# Minikube 環境：tcp://192.168.49.2:2376 或類似 IP# 或者檢查環境變數env | grep DOCKER# 如果在 Minikube 環境中找不到映像，切換到正確環境eval $(minikube docker-env)  # 切換到 Minikubedocker images  # 確認映像存在# 如果需要切回本地環境eval $(minikube docker-env -u)\n\n3. 私有倉庫認證失敗\n驗證 Secret 中的憑證是否正確\n檢查 Secret 是否在正確的命名空間中\n確認倉庫伺服器地址格式正確\n\n4. 映像拉取速度緩慢\n考慮使用映像快取或本地倉庫\n檢查網路連線品質\n使用較小的映像或多階段構建\n\n最佳實務建議映像管理\n使用具體標籤：避免使用 latest 標籤\n映像掃描：定期掃描映像的安全漏洞\n映像分層：優化 Dockerfile 以減少映像大小\n定期更新：保持映像為最新版本\n\n安全性\n最小權限：使用最小權限的 ServiceAccount\nSecret 管理：定期輪換 Image Pull Secret\n網路隔離：在適當的情況下使用網路策略\n映像簽章：考慮使用映像簽章驗證\n\n效能優化\n本地快取：在開發環境中使用本地映像\n並行拉取：合理設定 Pod 的並行啟動數量\n映像預拉取：在節點上預先拉取常用映像\n資源限制：設定適當的資源限制避免資源競爭\n\n透過了解和正確使用這三種映像拉取方式，您可以在不同的環境和場景中高效、安全地管理 Kubernetes 應用程式的容器映像。\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes Namespace 使用指南","url":"/2025/10/10/kubernetes-namespace/","content":"Kubernetes Namespace 使用指南什麼是 Namespace？Kubernetes Namespace 是一個 API 物件，用於在 Kubernetes 叢集中創建虛擬的資源隔離環境。Namespace 提供了一種將叢集資源劃分為多個獨立區域的方式，讓不同的團隊、專案或環境可以在同一個叢集中安全地共存。\nNamespace 的主要功能：\n資源隔離：將不同的應用程式或環境分隔在不同的命名空間中\n存取控制：透過 RBAC 實現細粒度的權限管理\n資源配額管理：限制每個命名空間可使用的叢集資源量\n名稱空間管理：避免資源名稱衝突，支援相同名稱的資源存在於不同命名空間\n\n為什麼使用 Namespace？相較於將所有資源都放在預設命名空間中，Namespace 提供了更好的資源管理方式：\n\n多租戶支援：讓多個團隊或專案安全地共享同一個 Kubernetes 叢集\n環境分離：清楚區分開發、測試、生產等不同環境的資源\n資源管理：透過資源配額控制每個環境的資源使用量\n權限控制：實現精細的存取權限管理，提升安全性\n\n\n\n\n預設 NamespaceKubernetes 叢集預設會創建四個系統命名空間：\n\nkube-system: 存放 Kubernetes 系統元件，如 kube-dns、kube-proxy、etcd 等核心服務\nkube-public: 公開可讀的命名空間，通常用於存放叢集資訊，所有使用者（包括未認證使用者）都可以讀取\nkube-node-lease: 用於 Node 租約物件，幫助確定 Node 的可用性和健康狀態\ndefault: 預設命名空間，當沒有指定命名空間時，資源會被創建在這裡\n\n建立自定義 Namespace方法一：使用 YAML 檔案建立建立 dockertest-namespace.yaml 檔案：\napiVersion: v1kind: Namespacemetadata:  name: dockertest-namespace  labels:    name: dockertest-namespace    environment: dev\n\n套用設定檔：\nkubectl create -f dockertest-namespace.yaml\n\n\n\n方法二：使用指令直接建立kubectl create namespace dockertest-namespace\n\n檢視所有 Namespacekubectl get namespaces# 或使用簡寫kubectl get ns\n\n在指定 Namespace 中操作資源在特定 Namespace 建立資源# 在指定的 namespace 中建立 podkubectl run nginx --image=nginx -n dockertest-namespace# 使用 YAML 檔案建立資源到指定 namespacekubectl apply -f dockertest-deployment.yaml -n dockertest-namespace\n\n\n\n設定預設 Namespace# 設定當前 context 的預設 namespacekubectl config set-context --current --namespace=dockertest-namespace# 確認目前的 context 設定kubectl config view --minify | grep namespace\n\n\n\n檢視 Namespace 中的資源# 檢視指定 namespace 中的所有 podkubectl get pods -n dockertest-namespace# 檢視所有 namespace 中的 podkubectl get pods --all-namespaces# 檢視 namespace 的詳細資訊kubectl describe namespace dockertest-namespace\n\n\n\n刪除 Namespace注意：刪除 Namespace 會同時刪除該命名空間內的所有資源！\nkubectl delete namespace dockertest-namespace\n\n\n\n資源配額管理為 Namespace 設定資源限制，避免某個環境消耗過多叢集資源：\napiVersion: v1kind: ResourceQuotametadata:  name: compute-quota  namespace: dockertest-namespacespec:  hard:    requests.cpu: &quot;4&quot;    requests.memory: 8Gi    limits.cpu: &quot;8&quot;    limits.memory: 16Gi    persistentvolumeclaims: &quot;10&quot;    pods: &quot;10&quot;\n\n最佳實踐建議\n環境分離：為不同環境（開發、測試、生產）建立獨立的命名空間\n團隊隔離：為不同團隊或專案建立專用的命名空間\n命名規範：採用一致的命名規範，如 team-environment 格式\n資源配額：為每個命名空間設定合適的資源配額\n權限控制：結合 RBAC 實現細粒度的權限管理\n監控標籤：為命名空間加上有意義的標籤，便於監控和管理\n\n範例命名建議：\n\nfrontend-dev、frontend-prod\nbackend-staging、backend-prod\nteam-alpha-dev、team-beta-prod\n\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes Secret 使用指南","url":"/2025/11/02/kubernetes-secret-intro/","content":"Kubernetes Secret 使用指南什麼是 Secrets？Kubernetes Secrets 是一個 API 物件，用於存儲和管理敏感資訊，如密碼、OAuth 權杖、SSH 金鑰等。Secrets 類似於 ConfigMap，但專門設計用於保存機密資料，提供了額外的安全性保護。\nSecrets 的主要功能：\n敏感資料存儲：安全地存儲密碼、金鑰、憑證等敏感資訊\n資料加密：在 etcd 中以 Base64 編碼存儲（可配置加密）\n存取控制：透過 RBAC 控制對敏感資料的存取\n多種類型支援：支援不同類型的機密資料格式\n\n為什麼使用 Secrets？相較於將敏感資料硬編碼在應用程式或 ConfigMap 中，Secrets 提供了更安全的管理方式：\n\n安全性：敏感資料與應用程式程式碼分離\n存取控制：精細的權限管理和審計功能\n靈活性：支援多種掛載和使用方式\n合規性：符合企業安全和合規要求\n\n\n\n\nSecrets 類型和配置Opaque Secrets（通用型）最常用的 Secret 類型，用於存儲任意的使用者定義資料：\napiVersion: v1kind: Secretmetadata:  name: dockertest-secret  namespace: dockertest-namespace  labels:    app: dockertesttype: Opaquedata:  # Base64 編碼的資料  username: cm9vdA==          # root  password: MTIzNDU2          # 123456  api-key: YWJjZGVmZ2hpams=   # abcdefghijk    # 或使用 stringData（自動編碼）stringData:  database-url: &quot;postgresql://user:pass@localhost:5432/db&quot;  secret-token: &quot;my-secret-token-value&quot;\n\nDocker Registry Secrets用於私有映像倉庫的身份驗證：\napiVersion: v1kind: Secretmetadata:  name: docker-registry-secret  namespace: dockertest-namespacetype: kubernetes.io/dockerconfigjsondata:  .dockerconfigjson: eyJhdXRocyI6eyJyZWdpc3RyeS5leGFtcGxlLmNvbSI6eyJ1c2VybmFtZSI6InVzZXIiLCJwYXNzd29yZCI6InBhc3MiLCJhdXRoIjoiZFhObGNqcHdZWE56In19fQ==\n\nTLS Secrets用於存儲 TLS 憑證和私鑰：\napiVersion: v1kind: Secretmetadata:  name: tls-secret  namespace: dockertest-namespacetype: kubernetes.io/tlsdata:  tls.crt: LS0tLS1CRUdJTi... # Base64 編碼的憑證  tls.key: LS0tLS1CRUdJTi... # Base64 編碼的私鑰\n\nService Account Token Secrets用於服務帳戶權杖：\napiVersion: v1kind: Secretmetadata:  name: service-account-secret  namespace: dockertest-namespace  annotations:    kubernetes.io/service-account.name: &quot;my-service-account&quot;type: kubernetes.io/service-account-token\n\n在 Pod 中使用 Secrets方法一：作為環境變數apiVersion: apps/v1kind: Deploymentmetadata:  name: dockertest-deployment  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: dockertest  template:    metadata:      labels:        app: dockertest    spec:      containers:      - name: dockertest        image: docker.io/pcion123/tinydocker:0.0.10        env:        # 引用特定的 Secret 鍵        - name: DB_USERNAME          valueFrom:            secretKeyRef:              name: dockertest-secret              key: username        - name: DB_PASSWORD          valueFrom:            secretKeyRef:              name: dockertest-secret              key: password        # 引用整個 Secret 作為環境變數        envFrom:        - secretRef:            name: dockertest-secret\n\n\n\n方法二：作為檔案掛載apiVersion: apps/v1kind: Deploymentmetadata:  name: app-with-secret-files  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: app-with-secrets  template:    metadata:      labels:        app: app-with-secrets    spec:      containers:      - name: app        image: nginx:alpine        volumeMounts:        # 掛載整個 Secret 為目錄        - name: secret-volume          mountPath: /etc/secrets          readOnly: true        # 掛載特定檔案到指定位置        - name: secret-token          mountPath: /etc/token/secret-token          subPath: secret-token          readOnly: true      volumes:      - name: secret-volume        secret:          secretName: dockertest-secret          # 設定檔案權限          defaultMode: 0400      - name: secret-token        secret:          secretName: dockertest-secret          items:          - key: secret-token            path: secret-token            mode: 0444\n\n\n\n方法三：用於 Image Pull SecretsapiVersion: apps/v1kind: Deploymentmetadata:  name: private-image-deployment  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: private-app  template:    metadata:      labels:        app: private-app    spec:      # 使用 Image Pull Secret      imagePullSecrets:      - name: docker-registry-secret      containers:      - name: app        image: private-registry.example.com/my-app:latest\n\n建立和管理 Secrets使用 kubectl 指令建立# 從字面值建立kubectl create secret generic my-secret \\  --from-literal=username=admin \\  --from-literal=password=secretpassword \\  -n dockertest-namespace# 從檔案建立kubectl create secret generic file-secret \\  --from-file=ssh-privatekey=/path/to/ssh/key \\  --from-file=ssh-publickey=/path/to/ssh/key.pub \\  -n dockertest-namespace# 建立 Docker Registry Secretkubectl create secret docker-registry regcred \\  --docker-server=registry.example.com \\  --docker-username=myuser \\  --docker-password=mypassword \\  --docker-email=myemail@example.com \\  -n dockertest-namespace# 建立 TLS Secretkubectl create secret tls tls-secret \\  --cert=path/to/tls.crt \\  --key=path/to/tls.key \\  -n dockertest-namespace\n\n管理指令# 查看 Secret 列表kubectl get secrets -n dockertest-namespace# 查看 Secret 詳細資訊（不顯示敏感資料）kubectl describe secret dockertest-secret -n dockertest-namespace# 查看 Secret 的 YAML 格式kubectl get secret dockertest-secret -n dockertest-namespace -o yaml# 解碼 Secret 資料kubectl get secret dockertest-secret -n dockertest-namespace -o jsonpath=&#x27;&#123;.data.username&#125;&#x27; | base64 -d# 編輯 Secretkubectl edit secret dockertest-secret -n dockertest-namespace# 刪除 Secretkubectl delete secret dockertest-secret -n dockertest-namespace\n\n更新 Secrets# 方法一：重新應用 YAML 檔案kubectl apply -f secret.yaml# 方法二：使用 patch 更新kubectl patch secret dockertest-secret -n dockertest-namespace \\  --type merge -p &#x27;&#123;&quot;stringData&quot;:&#123;&quot;new-key&quot;:&quot;new-value&quot;&#125;&#125;&#x27;# 方法三：替換整個 Secretkubectl replace -f updated-secret.yaml\n\n實際應用範例範例一：資料庫連線配置apiVersion: v1kind: Secretmetadata:  name: database-secret  namespace: dockertest-namespacetype: OpaquestringData:  DB_HOST: &quot;postgresql.example.com&quot;  DB_PORT: &quot;5432&quot;  DB_NAME: &quot;myapp&quot;  DB_USERNAME: &quot;appuser&quot;  DB_PASSWORD: &quot;super-secret-password&quot;  DB_URL: &quot;postgresql://appuser:super-secret-password@postgresql.example.com:5432/myapp&quot;---apiVersion: apps/v1kind: Deploymentmetadata:  name: database-app  namespace: dockertest-namespacespec:  replicas: 1  selector:    matchLabels:      app: database-app  template:    metadata:      labels:        app: database-app    spec:      containers:      - name: app        image: docker.io/pcion123/tinydocker:0.0.10        envFrom:        - secretRef:            name: database-secret\n\n範例二：多服務認證配置apiVersion: v1kind: Secretmetadata:  name: service-credentials  namespace: dockertest-namespacetype: OpaquestringData:  # API 服務認證  API_KEY: &quot;sk-1234567890abcdef&quot;  API_SECRET: &quot;secret-key-abcdef123456&quot;    # OAuth 配置  OAUTH_CLIENT_ID: &quot;my-client-id&quot;  OAUTH_CLIENT_SECRET: &quot;my-client-secret&quot;    # JWT 金鑰  JWT_SECRET: &quot;jwt-signing-secret-key&quot;    # 外部服務 Token  GITHUB_TOKEN: &quot;ghp_1234567890abcdef&quot;  SLACK_WEBHOOK: &quot;https://hooks.slack.com/services/...&quot;\n\n範例三：SSL&#x2F;TLS 憑證配置apiVersion: v1kind: Secretmetadata:  name: app-tls-secret  namespace: dockertest-namespacetype: kubernetes.io/tlsdata:  tls.crt: |    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...  tls.key: |    LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0t...---apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: app-ingress  namespace: dockertest-namespacespec:  tls:  - hosts:    - app.example.com    secretName: app-tls-secret  rules:  - host: app.example.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: app-service            port:              number: 80\n\n安全性最佳實務Secret 管理\n最小權限原則：只授予必要的 Secret 存取權限\n定期輪換：定期更新密碼和金鑰\n版本控制：避免將 Secret 內容提交到版本控制系統\n環境分離：為不同環境使用獨立的 Secret\n\n存取控制\nRBAC 配置：使用 Role-Based Access Control 限制存取\n命名空間隔離：利用命名空間隔離不同應用的 Secret\nServiceAccount 管理：為不同應用使用專用的 ServiceAccount\n審計日誌：啟用 Secret 存取的審計記錄\n\n加密和存儲\n靜態加密：啟用 etcd 中 Secret 的加密\n傳輸加密：確保 API 通信使用 TLS\n記憶體保護：避免將 Secret 寫入磁碟交換區\n備份安全：確保備份中的 Secret 也被加密\n\n應用程式整合\n環境變數 vs 檔案：根據安全要求選擇適當的掛載方式\n檔案權限：設定適當的檔案權限和擁有者\n程序隔離：避免在日誌或錯誤訊息中洩露 Secret\n清理策略：應用程式退出時清理記憶體中的敏感資料\n\n疑難排解常見問題1. Pod 無法存取 Secret# 檢查 Secret 是否存在kubectl get secret dockertest-secret -n dockertest-namespace# 檢查 Pod 的服務帳戶權限kubectl describe pod &lt;pod-name&gt; -n dockertest-namespace# 查看 RBAC 配置kubectl auth can-i get secrets --as=system:serviceaccount:dockertest-namespace:default\n\n2. Secret 資料解碼問題# 檢查 Secret 內容kubectl get secret dockertest-secret -n dockertest-namespace -o yaml# 手動解碼 Base64 資料echo &quot;cm9vdA==&quot; | base64 -d# 檢查編碼格式是否正確kubectl get secret dockertest-secret -n dockertest-namespace -o jsonpath=&#x27;&#123;.data.username&#125;&#x27; | base64 -d\n\n3. Image Pull Secret 失效# 測試 Docker Registry 連線docker login registry.example.com# 重新建立 Image Pull Secretkubectl delete secret regcred -n dockertest-namespacekubectl create secret docker-registry regcred \\  --docker-server=registry.example.com \\  --docker-username=newuser \\  --docker-password=newpassword \\  -n dockertest-namespace# 檢查 Pod 使用的 Image Pull Secretkubectl describe pod &lt;pod-name&gt; -n dockertest-namespace\n\n4. Secret 更新後 Pod 未重新載入# 重啟 Deployment 以載入新的 Secretkubectl rollout restart deployment dockertest-deployment -n dockertest-namespace# 檢查重啟狀態kubectl rollout status deployment dockertest-deployment -n dockertest-namespace# 驗證新 Secret 是否生效kubectl exec -it &lt;pod-name&gt; -n dockertest-namespace -- env | grep DB_PASSWORD\n\n進階配置使用外部 Secret 管理器# 使用 External Secrets OperatorapiVersion: external-secrets.io/v1beta1kind: SecretStoremetadata:  name: vault-backend  namespace: dockertest-namespacespec:  provider:    vault:      server: &quot;https://vault.example.com&quot;      path: &quot;secret&quot;      version: &quot;v2&quot;      auth:        tokenSecretRef:          name: &quot;vault-token&quot;          key: &quot;token&quot;---apiVersion: external-secrets.io/v1beta1kind: ExternalSecretmetadata:  name: vault-secret  namespace: dockertest-namespacespec:  refreshInterval: 15s  secretStoreRef:    name: vault-backend    kind: SecretStore  target:    name: myapp-secret    creationPolicy: Owner  data:  - secretKey: password    remoteRef:      key: secret/myapp      property: password\n\n自動 Secret 輪換apiVersion: batch/v1kind: CronJobmetadata:  name: secret-rotation  namespace: dockertest-namespacespec:  schedule: &quot;0 2 * * 0&quot;  # 每週日凌晨 2 點  jobTemplate:    spec:      template:        spec:          containers:          - name: rotate-secrets            image: secret-rotator:latest            command:            - /bin/sh            - -c            - |              # 更新 Secret 的腳本邏輯              kubectl patch secret dockertest-secret \\                --type merge \\                -p &#x27;&#123;&quot;stringData&quot;:&#123;&quot;password&quot;:&quot;&#x27;$(generate-new-password)&#x27;&quot;&#125;&#125;&#x27;          restartPolicy: OnFailure\n\n透過正確使用和管理 Kubernetes Secrets，您可以安全地處理應用程式的敏感資料，確保符合企業安全標準，同時保持應用程式的靈活性和可維護性。\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"設置Linux環境變數","url":"/2019/03/10/linux-environmentvariables/","content":"我們在進行環境開發的時候常常需要用到一些系統路徑，那這些路徑我們可以用系統的環境變數來讓他大大縮減打字的長度，以下就介紹我們如何來建立這些環境變數\nlinux提供兩種設置環境變數的方式 -&gt; 使用者環境變數 &amp; 系統環境變數\n\n\n使用者環境變數使用者環境變數儲存在以下檔案中：~&#x2F;.profile~&#x2F;.bashrc~&#x2F;.bash_profile~&#x2F;.bash_login\n系統環境變數系統環境變數儲存在以下檔案中：&#x2F;etc&#x2F;profile&#x2F;etc&#x2F;profile.d&#x2F;etc&#x2F;bash.bashrc\n加入系統環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport JAVA_HOME=/usr/lib/jvm/jdk1.7.0export PATH=$PATH:$JAVA_HOME/bin\n\n環境變數更改後,將在使用者下次登陸時生效如果想立刻生效,則執行下面的語句\n$ source /etc/profile\n\n生效後我們可以進行測試\n$ echo $JAVA_HOME\n\n成功後應當看到剛剛我們我設置的路徑另外如果想查看當前系統所設置的路徑有哪些可以輸入：\n$ echo $PATH\n他會顯示當前所有的環境路徑有哪些\n","categories":["linux"],"tags":["linux","環境變數"]},{"title":"安裝Maven","url":"/2019/03/16/maven-install/","content":"安裝Maven先下載maven：\n$ wget https://www-us.apache.org/dist/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz\n解開包:\n$ tar xzvf apache-maven-3.6.0-bin.tar.gz\n移動到&#x2F;opt&#x2F;底下：\n$ mv apache-maven-3.6.0-bin /opt\n\n設置Maven環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport MAVEN_HOME=/opt/apache-maven-3.6.0export M2_HOME=/opt/apache-maven-3.6.0export PATH=$PATH:$MAVEN_HOME/binexport PATH=$PATH:$M2_HOME/bin","categories":["maven"],"tags":["linux","maven"]},{"title":"Ubuntu安裝Minikube (2025)","url":"/2025/09/23/minikube-install-2025/","content":"在現代容器化開發環境中，Minikube 是學習和測試 Kubernetes 的絕佳工具。本文將詳細介紹如何在 Ubuntu 24.04.3 LTS 上完整建置 Minikube 環境，包含 Docker 容器引擎、kubectl 命令列工具，以及完整的 Tomcat 服務部署範例。\n無論您是 Kubernetes 初學者還是需要本地開發環境的工程師，這篇指南都將協助您快速建立一個功能完整的本地 Kubernetes 集群。\n環境需求\n作業系統: Ubuntu 24.04.3 LTS\n記憶體: 建議至少 4GB RAM\n硬碟空間: 建議至少 20GB 可用空間\n網路: 可存取網際網路進行套件下載\n\n\n\n第一步：系統前置準備在開始安裝之前，我們需要更新系統套件並安裝必要的基礎工具。這些工具將為後續的 Docker 和 Kubernetes 組件安裝提供支援。\n# 更新系統套件資料庫並升級現有套件sudo apt update &amp;&amp; sudo apt upgrade -y# 安裝必要的基礎工具# curl: 用於下載檔案# wget: 另一個下載工具# apt-transport-https: 支援 HTTPS 來源# ca-certificates: 憑證管理# software-properties-common: 軟體來源管理# conntrack: Kubernetes 網路追蹤所需sudo apt install -y curl wget apt-transport-https ca-certificates software-properties-common conntrack\n\n第二步：安裝 Docker 容器引擎Docker 是 Minikube 的容器運行時環境。Minikube 支援多種容器引擎，但 Docker 是最常用且穩定的選擇。\n# 安裝 Docker 社群版本sudo apt install -y docker.io# 啟動 Docker 服務並設定為開機自動啟動sudo systemctl enable --now docker# 將目前使用者加入 docker 群組，避免每次都需要 sudosudo usermod -aG docker $USER\n\n這一步完成後需要 重新登入系統 或執行 newgrp docker 讓群組變更生效。\n\n重要提醒: 將使用者加入 docker 群組可以避免每次執行 Docker 指令時都需要 sudo 權限，但請注意這會給予該使用者等同 root 的權限來操作 Docker。\n\n# 驗證 Docker 安裝是否成功docker version\n\n第三步：安裝 kubectl 命令列工具kubectl 是 Kubernetes 的官方命令列工具，用於與 Kubernetes 集群進行互動。它可以讓我們管理 Pod、Service、Deployment 等各種 Kubernetes 資源。\n# 取得最新穩定版本的版本號$KUBECTL_VER=$(curl -L -s https://dl.k8s.io/release/stable.txt)# 下載對應版本的 kubectl 執行檔curl -LO &quot;https://dl.k8s.io/release/$KUBECTL_VER/bin/linux/amd64/kubectl&quot;# 賦予執行權限chmod +x kubectl# 移動到系統執行路徑sudo mv kubectl /usr/local/bin/# 驗證 kubectl 安裝是否成功kubectl version --client\n\n第四步：安裝並設定 MinikubeMinikube 是一個輕量級的 Kubernetes 實作，設計用於在本地環境運行單節點的 Kubernetes 集群。它非常適合開發、測試和學習 Kubernetes。\n基礎安裝# 下載最新版本的 Minikubecurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64# 安裝到系統執行路徑sudo install minikube-linux-amd64 /usr/local/bin/minikube# 驗證 Minikube 安裝是否成功minikube version\n\n以下是 Minikube 的常用操作指令，建議先熟悉這些基本指令：\n# 查看 Minikube 版本資訊minikube version# 查看目前集群狀態minikube status# 啟動 Kubernetes 集群minikube start# 停止集群（保留資料）minikube stop\n\n啟動 Minikube 集群在完成安裝後，我們可以開始啟動並測試 Minikube 集群：\n\n啟動minikube\n\n# 使用 Docker 作為容器引擎啟動集群minikube start --driver=docker# 啟動集群並指定特定的 Kubernetes 版本minikube start --driver=docker --kubernetes-version=v1.29.0\n\n\n建立外部存取代理\n\n# 建立代理連線，允許外部存取 Kubernetes APIkubectl proxy --address=&#x27;0.0.0.0&#x27; --disable-filter=true\n\n\n注意: 此指令會在背景持續運行，建議在新的終端視窗中執行\n\n\n\n\n存取 Kubernetes Dashboard\n\n# 啟動 Web 介面儀表板並取得存取網址minikube dashboard --url\n\n此指令會輸出一個網址，您可以在瀏覽器中開啟此網址來存取 Kubernetes 的視覺化管理介面。\n\n\n查看dashboard實際運行結果\n\n\n實戰範例：部署 Tomcat 應用程式為了驗證 Minikube 環境運作正常，我們將部署一個完整的 Tomcat Web 應用程式作為示範。\n步驟一：啟用 Ingress 控制器# 啟用 Ingress 控制器附加元件minikube addons enable ingress# 等待 Ingress 控制器 Pod 準備完成kubectl -n ingress-nginx get pods -l app.kubernetes.io/component=controller -w\n\n\n提示: 使用 -w 參數可以持續監看 Pod 狀態變化，看到 Running 狀態時按 Ctrl+C 退出\n\n步驟二：準備 Kubernetes YAML 配置檔以下是一個完整的 Tomcat 部署配置，包含 Deployment、Service 和 Ingress 三個資源：\napiVersion: apps/v1kind: Deploymentmetadata:  name: tomcat-deploymentspec:  replicas: 1  selector:    matchLabels:      app: tomcat  template:    metadata:      labels:        app: tomcat    spec:      containers:      - name: tomcat        image: tomcat:10.1-jdk17        ports:        - containerPort: 8080        command: [&quot;/bin/sh&quot;,&quot;-c&quot;]        args:          - cp -r /usr/local/tomcat/webapps.dist/ROOT /usr/local/tomcat/webapps/ &amp;&amp; exec catalina.sh run        readinessProbe:          httpGet:            path: /            port: 8080          initialDelaySeconds: 10          periodSeconds: 5---apiVersion: v1kind: Servicemetadata:  name: tomcat-servicespec:  type: ClusterIP  selector:    app: tomcat  ports:    - name: http      port: 8080      targetPort: 8080---apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: tomcat-ingressspec:  ingressClassName: nginx  rules:  - http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: tomcat-service            port:              number: 8080\n\n步驟三：部署服務到集群# 部署 YAML 配置到集群kubectl apply -f tomcat.yaml# 查看 Pod 運行狀態kubectl get pods# 查看所有相關資源狀態kubectl get deployment,service,ingress\n\n驗證服務是否正常運行：\n# 取得 Minikube 集群 IP 位址$MINIKUBE_IP=$(minikube ip)# 查看 Minikube IPecho &quot;Minikube IP: $MINIKUBE_IP&quot;\n\n現在可以在瀏覽器中開啟 http://$MINIKUBE_IP 來查看 Tomcat 歡迎頁面。\n\n\nVirtualBox 環境特殊設定如果您是在 VirtualBox 虛擬機中運行 Ubuntu Server，需要進行額外的網路設定以便從主機存取服務。\nSSH 隧道設定由於 VirtualBox NAT 網路的限制，我們需要建立 SSH 隧道來橋接主機與虛擬機內的服務：\n# 建立 SSH 隧道，將主機的 18080 埠轉發到 Minikube 的 80 埠# 假設您的 SSH 服務運行在虛擬機的 2222 埠上ssh -N -L 18080:$MINIKUBE_IP:80 -p 2222 $USER@127.0.0.1\n\n參數說明：\n\n-N: 不執行遠端指令，僅用於建立隧道\n-L 18080:$MINIKUBE_IP:80: 將本機 18080 埠轉發到目標的 80 埠\n-p 2222: SSH 服務埠號\n$USER@127.0.0.1: 使用者名稱和虛擬機位址\n\n設定完成後，您就可以在 Windows 主機的瀏覽器中輸入 http://localhost:18080 來存取 Tomcat 服務。\nVirtualBox NAT 設定確保您的 VirtualBox 虛擬機網路設定如下：\n\n網路介面卡設定為 NAT 模式\n進階設定中開啟埠轉發規則：\n\n\n\n網路架構圖下圖展示了完整的 Minikube + Tomcat + Ingress 網路架構：\n\n\n總結本文詳細介紹了在 Ubuntu 24.04.3 上建置 Minikube 開發環境的完整流程，包含：\n主要完成項目\n系統環境準備 - 安裝必要的基礎套件和工具\nDocker 容器引擎 - 作為 Minikube 的容器運行時\nkubectl 工具 - Kubernetes 的命令列管理介面\nMinikube 本機集群 - 單節點 Kubernetes 環境\n完整應用部署 - Tomcat Web 服務的實際範例\nIngress 控制器 - 處理外部流量的入口管理\nVirtualBox 整合 - 虛擬機環境下的網路設定\n\n下一步建議完成本教學後，您可以：\n\n嘗試部署其他類型的應用程式（如 MySQL、Redis 等）\n學習 Kubernetes 的進階概念（ConfigMap、Secret、PersistentVolume）\n探索 Minikube 的其他附加元件（Metrics Server、Dashboard 等）\n實驗不同的部署策略（Rolling Update、Blue-Green Deployment）\n\n常見問題排除\n如果遇到資源不足的問題，可以調整 Minikube 的記憶體和 CPU 配置\n若服務無法存取，請檢查防火牆設定和網路配置\nDocker 權限問題請確認使用者是否已加入 docker 群組\n\n透過這個環境，您已經具備了本地 Kubernetes 開發的基礎設施，可以開始探索容器編排和微服務架構的精彩世界。\n","categories":["kubernetes"],"tags":["linux","ubuntu","docker","kubernetes","minikube"]},{"title":"Ubuntu安裝Minikube","url":"/2021/08/21/minikube-install/","content":"繼上次的docker安裝今天要繼續部屬kubernetes的內容\n簡介minikube是由google開發的精簡版kubernetes工具可以簡單的模擬k8s底下的環境運作\n\n\n安裝容器kubernetese提供多樣的容器部屬環境這邊我們選用docker當作容器的底層\n請參考之前的文章\n\n安裝kubectlkubectl是一套管理kubernetes的命令工具\n安裝# 更新套件管理$ sudo apt update# 安裝套件倉庫$ sudo apt install -y apt-transport-https ca-certificates curl# 下載倉庫憑證$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg# 加入憑證信任列表$ echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main# 更新套件管理$ sudo apt update# 安裝kubectl$ sudo apt install kubectl -y\n\n查看版本$ kubectl version --short --clientClient Version: v1.22.1\n\n安裝minikube現在開始安裝主角\n安裝# 下載安裝包$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb# 安裝套件$ sudo dpkg -i minikube_latest_amd64.debSelecting previously unselected package minikube.(Reading database ... 71806 files and directories currently installed.)Preparing to unpack minikube_latest_amd64.deb ...Unpacking minikube (1.22.0-0) ...Setting up minikube (1.22.0-0) ...\n\n查看版本$ minikube versionminikube version: v1.22.0commit: a03fbcf166e6f74ef224d4a63be4277d017bb62e\n\n啟動$ minikube start😄  minikube v1.22.0 on Ubuntu 20.04 (vbox/amd64)✨  Automatically selected the docker driver. Other choices: ssh, none👍  Starting control plane node minikube in cluster minikube🚜  Pulling base image ...💾  Downloading Kubernetes v1.21.2 preload ...    &gt; preloaded-images-k8s-v11-v1...: 502.14 MiB / 502.14 MiB  100.00% 7.08 MiB    &gt; gcr.io/k8s-minikube/kicbase...: 361.08 MiB / 361.09 MiB  100.00% 3.95 MiB🔥  Creating docker container (CPUs=2, Memory=2200MB) ...🐳  Preparing Kubernetes v1.21.2 on Docker 20.10.7 ...    ▪ Generating certificates and keys ...    ▪ Booting up control plane ...    ▪ Configuring RBAC rules ...🔎  Verifying Kubernetes components...    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5🌟  Enabled addons: storage-provisioner, default-storageclass🏄  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default\n\n啟動dashboard正常的kubernetes的dashboard需要另外安裝的但是minikube已經自帶dashboard套件只需啟動就行了\n$ minikube dashboard🔌  Enabling dashboard ...    ▪ Using image kubernetesui/dashboard:v2.1.0    ▪ Using image kubernetesui/metrics-scraper:v1.0.4🤔  Verifying dashboard health ...🚀  Launching proxy ...🤔  Verifying proxy health ...🎉  Opening http://127.0.0.1:33657/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...👉  http://127.0.0.1:33657/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/\n\n開啟proxy一般來說啟動dashboard就會自動幫你開啟瀏覽器到dashboard的頁面中了但是筆者的環境是裝在virtualbox的ubuntu-server底下所以就需要另外提供外連的方式了\n$ kubectl proxy --address=&#x27;0.0.0.0&#x27; --port=8001 --accept-hosts=&#x27;^*$&#x27;Starting to serve on [::]:8001\n\n這樣就大功告成啦!\n\n\n補充安裝過程設定如果出了什麼問題想要重置我們可刪掉整個minikube設置重來\n# 刪除minikube環境$ minikube delete &amp;&amp; rm -rf ~/.minikube# 重啟minikube$ minikube start","categories":["kubernetes"],"tags":["linux","ubuntu","docker","kubernetes","minikube"]},{"title":"Ubuntu安裝Nexus","url":"/2021/09/25/nexus-install/","content":"安裝JDK請參考之前的文章\n\n下載nexus官方下載或者nexus-3.33.1-01-unix\n\n\n建立nexus使用者建立nexus專用的系統帳號\n$ useradd -M -d /opt/nexus -s /bin/bash -r nexus\n允許nexus用戶可以使用無密碼的sudo運行命令\n$ echo &quot;nexus   ALL=(ALL)       NOPASSWD: ALL&quot; &gt; /etc/sudoers.d/nexus\n\n安裝nexus先建立nexus目錄\n$ mkdir /opt/nexus\n解開nexus到剛剛建立好的目錄底下\n$ tar -zxvf nexus-3.33.1-01-unix.tar.gz -C /opt/nexus --strip-components=1\n修改權限\n$ chown -R nexus: /opt/nexus\n\n修改配置調整nexus內存大小調整自身機器合適的大小,這邊測試調整成2G\n開啟&#x2F;opt&#x2F;nexus&#x2F;bin&#x2F;nexus.vmoptions\n-Xms2048m-Xmx2048m-XX:MaxDirectMemorySize=2048m...\n\n調整nexus相對路徑因為剛剛解開nexus的時候把sonatype-work目錄的位置移上了一層所以這邊相對路徑就需要調整一下\n開啟&#x2F;opt&#x2F;nexus&#x2F;bin&#x2F;nexus.vmoptions\n...-XX:LogFile=./sonatype-work/nexus3/log/jvm.log...-Dkaraf.data=./sonatype-work/nexus3-Dkaraf.log=./sonatype-work/nexus3/log-Djava.io.tmpdir=./sonatype-work/nexus3/tmp\n\n修改nexus運行帳號修改nexus運行時使用帳號請修改成剛剛專門建立的帳號\n開啟&#x2F;opt&#x2F;nexus&#x2F;bin&#x2F;nexus.rc\nrun_as_user=&quot;nexus&quot;\n\n修改nexus對外port預設port是8081如果不需要調整請跳過這一步因為測試環境的關係這邊改成9090\n開啟&#x2F;opt&#x2F;nexus&#x2F;etc&#x2F;nexus-default.properties\n## DO NOT EDIT - CUSTOMIZATIONS BELONG IN $data-dir/etc/nexus.properties### Jetty sectionapplication-port=9090application-host=0.0.0.0\n\n啟動nexus啟動服務啟動\n$ sudo -u nexus /opt/nexus/bin/nexus start\n監看log監看log\n$ tail -f /opt/nexus/sonatype-work/nexus3/log/nexus.log\n\n第一次登入會看到以下畫面,預設帳號為admin\n\n\n獲取密碼獲取第一次登入密碼\n$ cat /opt/nexus/sonatype-work/nexus3/admin.password\n\n初始設定1.修改管理者密碼2.根據需求調整,這邊我選擇關閉匿名用戶登入3.關閉問題回饋\n\n登入後做完第一次設定後服務就正式裝好啦!\n\n\n系統服務建立腳本建立&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nexus.service\n[Unit]Description=nexus serviceAfter=network.target[Service]Type=forkingLimitNOFILE=65536ExecStart=/opt/nexus/bin/nexus startExecStop=/opt/nexus/bin/nexus stopUser=nexusRestart=on-abort[Install]WantedBy=multi-user.target\n\n重載systemd$ systemctl daemon-reload\n\n啟用服務$ systemctl enable --now nexus.service\n\n查看服務狀態$ systemctl status nexus.service\n\n服務正常運行,這樣我們以後就可以透過systemctl管理服務了\nroot@pcionserver:/etc/systemd/system# root@pcionserver:/etc/systemd/system# systemctl status nexus.service● nexus.service - nexus service     Loaded: loaded (/etc/systemd/system/nexus.service; enabled; vendor preset: enabled)     Active: active (running) since Sat 2021-09-25 07:51:16 UTC; 6min ago    Process: 8292 ExecStart=/opt/nexus/bin/nexus start (code=exited, status=0/SUCCESS)   Main PID: 8486 (java)      Tasks: 80 (limit: 4616)     Memory: 1.3G     CGroup: /system.slice/nexus.service             └─8486 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java -server -Dinstall4j.jvmDir=/usr/lib/jvm/java-8-openjdk-amd64/jre -Dexe4j.moduleName=/opt/nexus/bin/nexus -XX:+UnlockDiag&gt;Sep 25 07:51:16 pcionserver systemd[1]: Starting nexus service...Sep 25 07:51:16 pcionserver nexus[8292]: Starting nexusSep 25 07:51:16 pcionserver systemd[1]: Started nexus service.","categories":["maven"],"tags":["linux","maven","nexus"]},{"title":"安裝Nginx","url":"/2020/11/14/nginx-install/","content":"安裝Nginx$ apt install nginx\n\nconfig路徑# 查詢config路徑$ nginx -t# ubuntu預設會在/etc/nginx底下\n\n基本指令# 啟動nginx$ systemctl start nginx# 停止ngnix$ systemctl stop nginx# 重載ngnix$ systemctl reload nginx\n\n\n\n頁面測試 http://127.0.0.1\n\n以下內容偏向心得筆記\n設定proxyserver &#123;\t# 監聽 80 port    listen 80;    listen [::]:80;    # 設置進來的domainname或ip    server_name localhost;    # 設置routing    location / &#123;    \t# 轉發        proxy_pass http://localhost:9001;        # 轉發request的header內容        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;    &#125;&#125;\n\n設定loadbalance# 設置輪巡節點upstream servicemapping &#123;    server 127.0.0.1:9001 weight=3;    server 127.0.0.1:9002 weight=2;&#125;server &#123;\t# 監聽 80 port    listen 80;    listen [::]:80;    # 設置進來的domainname或ip    server_name my.app.test;\t# 設置routing    location / &#123;    \t# 轉發        proxy_pass http://servicemapping;        # 轉發request的header內容        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;    &#125;&#125;\n\n兩次請求結果\n","categories":["nginx"],"tags":["linux","nginx"]},{"title":"Ubuntu安裝PM2","url":"/2019/03/24/pm2-install/","content":"PM2是一套Node應用的進程管理器，當程式出現錯誤或者其他狀況死掉之後，這時候PM2就可以幫你的應用自動重啟，當然它不止這些功能，詳細可以看看官網介紹：PM2\n\n\n接下來我們要來介紹如何在ububtu上安裝它\n先更新套件：\n$ sudo apt update$ sudo apt upgrade\n\n安裝NodeJS已經安裝過的朋友可以跳過這一步\n安装NodeJS：\n$ sudo apt install nodejs\n然後我們要安裝n來幫我們管理nodejs版本：\n$ npm install -g n\n\n安裝NPM已經安裝過的朋友可以跳過這一步\n安装NPM：\n$ sudo apt install npm\n然後我們要安裝n來幫我們管理nodejs版本：\n$ npm install -g n\n\n安裝PM2接下來要開始正式安裝PM2：\n$ npm install pm2 -g\n完成PM2安裝步驟：\n$ pm2 completion install\n查看監控項目列表：\n$ pm2 ls\n\n查看監控詳細內容：\n$ pm2 monit\n","categories":["pm2"],"tags":["linux","ubuntu","pm2"]},{"title":"PM2監控程序","url":"/2019/03/24/pm2-watch/","content":"接下來我們要介紹如何簡單的監控我們應用\n\n\n測試腳本我們寫個簡單的腳本\nnano test.sh#!/bin/bashecho test is startfor v in &#123;1..10&#125;do\techo this is a echo\tsleep 1doneecho test is end\n\n建立PM2配置pm2允許我通過配置的方式來控制我們想要監控的方式，所以我們先產生一個基本的範例：\n$ pm2 init\npm2會幫我們產生一個名為ecosystem.config.js的檔案\n編輯PM2配置接下來要編輯這個檔案配置\nmodule.exports = &#123;  apps : [&#123;    name: &#x27;mytest&#x27;, // 任務名稱    script: &#x27;test.sh&#x27;, // 啟動腳本    // Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/    //args: &#x27;one two&#x27;,    instances: 1,    autorestart: true, // 自動重啟開關    max_restarts: 10, // 最大重啟次數    restart_delay: 30000, // 重啟時間間隔(毫秒)    watch: false,    max_memory_restart: &#x27;1G&#x27;,    env: &#123;      NODE_ENV: &#x27;development&#x27;    &#125;,    env_production: &#123;      NODE_ENV: &#x27;production&#x27;    &#125;  &#125;],  deploy : &#123;    production : &#123;      user : &#x27;node&#x27;,      host : &#x27;127.0.0.1&#x27;,      ref  : &#x27;origin/master&#x27;,      repo : &#x27;git@github.com:repo.git&#x27;,      path : &#x27;/var/www/production&#x27;,      &#x27;post-deploy&#x27; : &#x27;npm install &amp;&amp; pm2 reload ecosystem.config.js --env production&#x27;    &#125;  &#125;&#125;;\n\n操作PM2任務啟動任務：\n$ pm2 start ecosystem.config.js\n\n停止任務：\n$ pm2 stop ecosystem.config.js\n\n觀看監控：\n$ pm2 monit\n\n\n更多的介紹請上官網查詢：PM2教程\n","categories":["pm2"],"tags":["linux","pm2"]},{"title":"美化 PowerShell：Oh My Posh 全攻略 (2025)","url":"/2025/09/18/powershell-improve-2025/","content":"最近把內建的 Windows PowerShell 5.1 直接升級到跨平台的 PowerShell 7，啟動速度、互動補全與外觀自訂一次大進化。於是把這次從「升級 → 權限工具 (gsudo) → Prompt 美化 (Oh My Posh) → 文字&#x2F;字型 → 終端顏色主題」的完整流程整理成筆記，之後重裝或換機也能快速複製。 \n這篇你將會獲得：\n\n乾淨可重現的 Profile 初始化步驟\n提升效率的補全與權限操作設定\n一套漂亮又資訊量足夠的 Prompt 主題\nWindows Terminal 配色與字型建議\n\n先來看看升級前「尚未美化」的樣子，然後開始改造：\n\n\n\n\nPowerShell Profile 準備之後的功能（自動補全、別名、提示主題等）都會寫進個人 Profile。先確認目前的 $PROFILE 是否存在，沒有就建立。\n# 查看目前使用的 Profile 路徑echo $PROFILE# 檢查檔案是否存在（True = 已存在）Test-Path $PROFILE# 直接用記事本編輯notepad $PROFILE\n\nWindows PowerShell 5.1 目錄舊版（內建）使用的目錄名稱是 WindowsPowerShell。\n# 檢查舊版目錄是否存在Test-Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\WindowsPowerShell&quot;# 建立目錄（若不存在）New-Item -ItemType Directory -Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\WindowsPowerShell&quot; -Force# 建立 Profile（空檔案）New-Item -ItemType File -Path $PROFILE -Force\n\nPowerShell 7 目錄PowerShell 7 之後改用新目錄 PowerShell，不要混用。\n# 檢查新版目錄是否存在Test-Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\PowerShell&quot;# 建立目錄New-Item -ItemType Directory -Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\PowerShell&quot; -Force# 建立 ProfileNew-Item -ItemType File -Path $PROFILE -Force\n\n安裝 PowerShell 7使用 winget 最方便：\n# 安裝winget install --id Microsoft.Powershell --source winget# 更新winget upgrade --id Microsoft.Powershell\n\n啟用指令歷史 + AI 預測補全建議在 Profile 中加入 PSReadLine 設定：\n# 使用歷史紀錄 (History) + 外掛/擴充來源 (Plugin) 同時提供預測建議。# 其他可選值：None / History / Plugin / HistoryAndPluginSet-PSReadLineOption -PredictionSource HistoryAndPlugin# 將多筆建議以清單面板顯示於游標下方（ListView）。# 若偏好行內灰色字體，可改用：InlineViewSet-PSReadLineOption -PredictionViewStyle ListView\n\n若想立即測試：把以上貼進 notepad $PROFILE 開啟的檔案末端後存檔，再開新視窗生效。\ngsudo：快速取得系統權限gsudo 可視為 Windows 版 sudo，不用每次再手動啟動「以系統管理員身分執行」。\n# 安裝winget install gerardog.gsudo# 更新winget upgrade gerardog.gsudo\n\n在 Profile 中加入別名：\nSet-Alias sudo gsudo\n\n如果在 Windows Terminal 中想建立一個自動提權啟動 PowerShell 7 的命令，可在設定中指定：\ngsudo.exe &quot;C:\\Program Files\\PowerShell\\7\\pwsh.exe&quot;\n\n\n\nOh My Posh：Prompt 主題美化安裝 Nerd Font 字型先到 Nerd Fonts 官網 下載一款字型（建議 FiraCode &#x2F; Meslo &#x2F; JetBrainsMono），安裝後到 Windows Terminal 的該 Profile 內套用，避免符號亂碼。\n安裝 Oh My Poshwinget install JanDeDobbeleer.OhMyPosh -s wingetwinget upgrade JanDeDobbeleer.OhMyPosh\n\n啟用並指定主題在 Profile 內加入（可先用 notepad $PROFILE 開啟）：\n# 初始化（預設主題）oh-my-posh init pwsh | Invoke-Expression# 指定 paradox 主題（可改成任意 .omp.json）oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\paradox.omp.json&quot; | Invoke-Expression\n\n查看有哪些內建主題：\nGet-ChildItem $env:POSH_THEMES_PATH -Recurse -Filter &quot;*.omp.json&quot;\n\n修改後重新開一個新的 PowerShell 視窗即可看到效果。\n安裝 Git（若尚未安裝）winget install --id Git.Git -e --source wingetwinget upgrade Git.Git\n\nWindows Terminal 主題配色（Schemes）可到 Windows Terminal Themes 挑選喜歡的色票，將 JSON 片段貼進設定檔的 schemes 陣列，再於對應 Profile 設 &quot;colorScheme&quot; 為該名稱。\n\n\n例如 Espresso：\n&#123;  &quot;background&quot;: &quot;#323232&quot;,  &quot;black&quot;: &quot;#353535&quot;,  &quot;blue&quot;: &quot;#6C99BB&quot;,  &quot;brightBlack&quot;: &quot;#535353&quot;,  &quot;brightBlue&quot;: &quot;#8AB7D9&quot;,  &quot;brightCyan&quot;: &quot;#DCF4FF&quot;,  &quot;brightGreen&quot;: &quot;#C2E075&quot;,  &quot;brightPurple&quot;: &quot;#EFB5F7&quot;,  &quot;brightRed&quot;: &quot;#F00C0C&quot;,  &quot;brightWhite&quot;: &quot;#FFFFFF&quot;,  &quot;brightYellow&quot;: &quot;#E1E48B&quot;,  &quot;cursorColor&quot;: &quot;#D6D6D6&quot;,  &quot;cyan&quot;: &quot;#BED6FF&quot;,  &quot;foreground&quot;: &quot;#FFFFFF&quot;,  &quot;green&quot;: &quot;#A5C261&quot;,  &quot;name&quot;: &quot;Espresso&quot;,  &quot;purple&quot;: &quot;#D197D9&quot;,  &quot;red&quot;: &quot;#D25252&quot;,  &quot;selectionBackground&quot;: &quot;#5B5B5B&quot;,  &quot;white&quot;: &quot;#EEEEEC&quot;,  &quot;yellow&quot;: &quot;#FFC66D&quot;&#125;\n\n開啟 JSON 設定：\n\n\n\n將上述片段加入 schemes。\n在對應的 Profile 中設定：&quot;colorScheme&quot;: &quot;Espresso&quot;。\n\nVS Code 終端機設定如果你有在使用 VS Code，記得同步調整編輯器內建終端機的字型設定，否則 Oh My Posh 的特殊符號會出現亂碼。\n設定步驟\n開啟 VS Code 設定（Ctrl + , 或 File &gt; Preferences &gt; Settings）\n搜尋 terminal.integrated.fontFamily\n將字型設定為你剛才安裝的 Nerd Font，例如：&#x27;FiraCode Nerd Font&#x27;, &#x27;Meslo LG M DZ for Powerline&#x27;, Consolas, &#x27;Courier New&#x27;, monospace\n\n建議設定值&#123;  &quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;FiraCode Nerd Font&#x27;&quot;,  &quot;terminal.integrated.fontSize&quot;: 14,  &quot;terminal.integrated.cursorBlinking&quot;: true,  &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;&#125;\n\n這樣設定後，VS Code 內建終端機就能正確顯示 Oh My Posh 的所有圖示和符號了。\n\n\n成果展示\n\n希望這篇能幫助你快速打造一個好看、好讀、好用的終端環境。如果你有更喜歡的主題或額外技巧，也歡迎分享交流 🙌\n","categories":["windows"],"tags":["windows","powershell","terminal","vscode"]},{"title":"美化PowerShell - oh-my-posh","url":"/2020/03/08/powershell-improve/","content":"\n\n厭倦windows預設的powershell主題了嗎?現在開始來改造它吧!!!\n\n\n安裝套件首先打開powershell：\n# 安裝posh-git套件Install-Module posh-git -Scope CurrentUser# 安裝oh-my-posh套件Install-Module oh-my-posh -Scope CurrentUser\n基本上都輸入Y到底就可以安裝完成了!\n設置設定檔建立powershel啟動設定檔\n# 取得設定檔位置$profile# 得到設定檔位置~\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\n打開Microsoft.PowerShell_profile.ps1設定檔，如果沒有請自行建立\n# 使用UTF-8編碼chcp 65001# 引用posh-gitImport-Module posh-git# 引用oh-my-poshImport-Module oh-my-posh# 設置Agnoster主題Set-Theme Agnoster\n\n安裝powerline字型由於windows預設的字型無法支援oh-my-posh所以我們需要另外安裝配合的字型檔\npowerline字型\n# clone項目git clone https://github.com/powerline/fonts.git# 執行install.ps1進行安裝.\\install.ps1\n\n調整powershell內容\n\n\n請選擇有powerline的字型\n\n\n配置顏色主題最後我們要用scoop來安裝colortool主題工具\n# 保證允許腳本執行set-executionpolicy remotesigned -scope currentuser# 安裝scoopiex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)# 安裝colortoolscoop install colortool\n接著我們就要來配置顏色主題\n# 取得預設主題列表colortool -s# 預設主題# campbell-legacy.ini# campbell.ini# cmd-legacy.ini# OneHalfDark.itermcolors# OneHalfLight.itermcolors# solarized_dark.itermcolors# solarized_light.itermcolors# 臨時查看主題樣式colortool &lt;主題名稱&gt;# 設置預設主題樣式colortool -d &lt;主題名稱&gt;\n\n選定主題\n# 設置OneHalfDark主題colortool OneHalfDark.itermcolors\n\n\n\n這樣我們就大功告成拉!!\n","categories":["windows"],"tags":["windows","powershell","terminal"]},{"title":"Ubuntu安裝RabbitMQ","url":"/2020/05/10/rabbitmq-install/","content":"安裝erlangrabbitmq需要依靠erlang驅動，所以我們需要先安裝erlang\n使用repository安裝:\n$ wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb$ sudo dpkg -i erlang-solutions_2.0_all.deb$ sudo apt install esl-erlang\n\n安裝rabbitmqgithub手動安裝:\n$ wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server_3.8.3-1_all.deb$ sudo dpkg -i rabbitmq-server_3.8.3-1_all.deb\n\n\n\n如果安裝過程有問題可以試著apt指令修復\n$ sudo apt --fix-broken install\n\n修改rabbitmq管理插件安裝完rabbitmq之後,我們會需要一個可以管理的工具,rabbitmq很好的提供web的管理工具\n$ rabbitmq-plugins enable rabbitmq_management\n\n安裝完畢後重啟服務接著在瀏覽器輸入http://localhost:15672\n\n\n修改rabbitmq設置因為rabbitmq預設guest帳號只給本機登入，如果需要開放外部登入就要修改設置\n打開&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config，加入以下設置\n[\t&#123;\t\trabbit,\t\t[&#123;loopback_users, [&quot;guest&quot;]&#125;]\t&#125;].\n\n重啟服務之後我們就可以用guset帳號登入了\n","categories":["linux"],"tags":["linux","ubuntu","rabbitmq"]},{"title":"TelegramBot申請與開發","url":"/2019/11/09/telegrambot-install/","content":"telegrambot的使用與開發相較於linebot來說是好上手很多接下來就是介紹開發與使用方式\n\n\ntelegrambot 申請在telegram search bar上搜尋@BotFather然後完成附圖的流程\n\n\ntelegrambot API使用https://api.telegram.org/bot&#123;token&#125;/getUpdates# 取得chatid&#123;    &quot;ok&quot;: true,    &quot;result&quot;: [        &#123;            &quot;update_id&quot;: 123456789,            &quot;message&quot;: &#123;                &quot;message_id&quot;: 99,                &quot;from&quot;: &#123;                    &quot;id&quot;: 123456789,                    &quot;is_bot&quot;: false,                    &quot;first_name&quot;: &quot;&quot;,                    &quot;last_name&quot;: &quot;&quot;,                    &quot;username&quot;: &quot;&quot;,                    &quot;language_code&quot;: &quot;&quot;                &#125;,                &quot;chat&quot;: &#123;                    &quot;id&quot;: -314847207,                    &quot;title&quot;: &quot;this is a title&quot;,                    &quot;type&quot;: &quot;group&quot;,                    &quot;all_members_are_administrators&quot;: true                &#125;,                &quot;date&quot;: 1573288754,                &quot;text&quot;: &quot;messsage&quot;            &#125;        &#125;    ]&#125;\n\nhttps://api.telegram.org/bot&#123;token&#125;/sendMessage?chat_id=&#123;channelid&#125;&amp;text=&#123;message&#125;# 嘗試發送訊息&#123;    &quot;ok&quot;: true,    &quot;result&quot;: &#123;        &quot;message_id&quot;: 99,        &quot;from&quot;: &#123;            &quot;id&quot;: 123456789,            &quot;is_bot&quot;: true,            &quot;first_name&quot;: &quot;&quot;,            &quot;username&quot;: &quot;&quot;        &#125;,        &quot;chat&quot;: &#123;            &quot;id&quot;: 123456789,            &quot;title&quot;: &quot;this is a title&quot;,            &quot;type&quot;: &quot;group&quot;,            &quot;all_members_are_administrators&quot;: true        &#125;,        &quot;date&quot;: 1573289062,        &quot;text&quot;: &quot;messsage&quot;    &#125;&#125;\n\n更多API參考 Telegram Bot API\ntelegrambot JAVASDK使用maven引用\n&lt;dependency&gt;  &lt;groupId&gt;org.telegram&lt;/groupId&gt;  &lt;artifactId&gt;telegrambots&lt;/artifactId&gt;  &lt;version&gt;4.4.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n繼承TelegramLongPollingBot\n@Overridepublic String getBotUsername()&#123;\treturn &quot;userName&quot;;&#125;@Overridepublic String getBotToken()&#123;\treturn &quot;token&quot;;&#125;@Overridepublic void onUpdateReceived(Update update)&#123;\tif (update.hasMessage() &amp;&amp; update.getMessage().hasText())\t&#123;\t\tUser user = update.getMessage().getFrom();\t\tString rcvMessage = update.getMessage().getText();\t\tString source = String.format(&quot;收到來自[%s%s]的訊息內容=%s&quot;, user.getFirstName(), user.getLastName(), rcvMessage);\t\tSendMessage message = new SendMessage().setChatId(update.getMessage().getChatId()).setText(source);\t\ttry\t\t&#123;\t\t\texecute(message);\t\t&#125;\t\tcatch (Exception e)\t\t&#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\nBotClass使用\npublic static void main(String[] args)&#123;\tApiContextInitializer.init();\tTelegramBotsApi botsApi = new TelegramBotsApi();\ttry\t&#123;\t\tbotsApi.registerBot(new Telegram());\t&#125;\tcatch (Exception e)\t&#123;\t\te.printStackTrace();\t&#125;&#125;\n\n最後完成範例\n","categories":["telegram"],"tags":["telegram","bot"]},{"title":"安裝Tomcat","url":"/2019/03/16/tomcat-install/","content":"安裝Tomcat先下載maven：\n$ wget https://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.16/bin/apache-tomcat-9.0.16.tar.gz\n解開包：\n$ tar xzvf apache-tomcat-9.0.16.tar.gz\n移動到&#x2F;opt&#x2F;底下：\n$ mv apache-tomcat-9.0.16 /opt\n\n設置Tomcat環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport TOMCAT_HOME=/opt/apache-tomcat-9.0.16export PATH=$PATH:$TOMCAT_HOME/bin","categories":["tomcat"],"tags":["linux","tomcat"]},{"title":"Ubuntu安裝MariaDB","url":"/2019/03/16/ubuntu-installmariadb/","content":"安裝mariadb在ubuntu底下安裝mariadb其實很方便，只要幾個指令就可以完成了：\n先更新套件：\n$ sudo apt update$ sudo apt upgrade\n\n安装MariaDB：\n$ sudo apt install mariadb-server\n\n啟動服務：\n$ sudo systemctl start mysql$ sudo systemctl enable mysql\n\n查看服務：\n$ sudo systemctl status mysql\n\n\n\n初始化mariadb$ sudo mysql_secure_installation# 是否要設置root權限密碼- Set root password? [Y/n] y# 是否要移除匿名登入- Remove anonymous users? [Y/n] y# 是否關閉遠端登入- Disallow root login remotely? [Y/n] y# 是否移除test預設庫- Remove test database and access to it? [Y/n] y# 是否重新載入資料表權限- Reload privilege tables now? [Y/n] y\n\n完成後我們可試著本機登入查看：\n$ sudo mysql -u root -p\n\n建立遠端使用者權限初始化db之後我們還需要建立一組帳號，提供使用者遠端登入使用\n建立使用者與權限：\n# 建立使用者$ CREATE USER &#x27;my_account&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;my_password&#x27;;# 建立使用者權限$ GRANT ALL PRIVILEGES ON *.* TO &#x27;my_account&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;my_password&#x27; WITH GRANT OPTION;# 刷新設置$ FLUSH PRIVILEGES;\n\n查看結果：\n# 查看使用者$ SELECT host,user,password FROM mysql.user;# 查看使用者權限$ SHOW GRANTS FOR &#x27;my_account&#x27;;\n\n完成後我們嘗試遠端登入查看：\n$ mysql -h 192.168.0.100 -u &#x27;my_account&#x27; -p\n\n修改mariadb設置如果還是不行就需要去修改mariadb的設定檔打開&#x2F;etc&#x2F;mysql&#x2F;mariadb.conf.d&#x2F;50-server.cnf，找到bind-address且將他註解掉\n# Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.# bind-address  = 127.0.0.1\n\n之後再重新啟動mariadb就可以了\n$ sudo systemctl restart mysql","categories":["linux"],"tags":["linux","ubuntu","mariadb"]},{"title":"Ubuntu安裝Redis","url":"/2019/03/16/ubuntu-installredis/","content":"安裝redis在ubuntu底下安裝redis跟安裝mariadb一樣，依靠apt指令就可以安裝完成：\n先更新套件：\n$ sudo apt update$ sudo apt upgrade\n\n安装Redis：\n$ sudo apt install redis-server\n\n安裝完成後redis會自動加入到服務中，查看服務：\n$ sudo systemctl status redis\n\n\n\n修改redis設置後我們要提供給遠端使用者使用就需要去修改設定檔，打開&#x2F;etc&#x2F;redis&#x2F;redis.conf，找到bind且將他註解掉\n# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# bind 127.0.0.1 ::1\n\n之後再重新啟動redis就可以了\n$ sudo systemctl restart redis","categories":["linux"],"tags":["linux","ubuntu","redis"]},{"title":"使用vscode+copilot快速建立專案","url":"/2025/07/30/vscode-copilot-quick/","content":"從 Eclipse 到 VSCode：我的 AI 輔助開發轉型之路嗨大家好！今天想跟大家分享一個讓我既興奮又有點緊張的決定 —— 我要從用了好幾年的 Eclipse 跳槽到 VSCode 了！🚀\n為什麼決定換編輯器？老實說，作為一個 Java 開發者，Eclipse 一直是我的好夥伴。但最近看到越來越多同事在用 VSCode，特別是搭配 GitHub Copilot 的開發體驗，讓我開始好奇：「我是不是錯過了什麼？」\n更重要的是，現在 AI 輔助開發工具發展得這麼快，我覺得是時候跟上這個潮流了。畢竟，誰不想寫 code 寫得更快、更聰明呢？😄\n準備好了嗎？讓我們一起踏上這段 AI 輔助開發的冒險之旅吧！ 🎉\n\n\n這篇文章會聊什麼？這次我想分享的重點是：如何用 VSCode + GitHub Copilot + 自定義 Prompts 來快速建立 Spring Boot 專案。\n具體來說，我會分享給大家：\n\n🎯 使用 .github/prompts/*.prompt.md 自定義提示詞\n⚡ 展示讓 AI 幫你快速搭建專案架構\n💡 一些我在轉換過程中學到的小技巧\n\n這次的實戰內容我錄了一個完整的操作影片，從零開始建立一個 Spring Boot 專案：\n📺 實戰教學影片：VSCode + AI 快速建立 Spring Boot 專案\n\n  \n    \n    \n  \n\n\n影片裡我會展示：\n\nVSCode 環境的基本設定\nGitHub Copilot 的神奇功能\n自定義 Prompt 模板的設計技巧\n實際建立一個可運行的 Spring Boot 應用\n\n使用體驗真實感想老實說，剛開始使用 VSCode + GitHub Copilot 的時候，我真的被震撼到了！😱\n流暢度方面：\n\n🚀 啟動速度：從點擊到可以開始寫 code，幾乎是秒開！跟 Eclipse 那種「先去泡杯咖啡」的等待完全不同\n⚡ 反應速度：打字的時候沒有任何延遲感，檔案切換也是瞬間完成\n🎯 記憶體使用：明顯比傳統 IDE 輕量很多，多開幾個專案也不會讓電腦卡到爆\n\nAI 輔助的驚艷之處：\n\n🧠 任務規劃能力：最讓我震撼的是 Copilot 能夠理解整個專案的架構，當我說「建立一個 Spring Boot 專案」時，它不只是給我片段程式碼，而是能建立一個完整可執行的專案\n🔥 執行效率：從 Controller、Service、Repository 到測試檔案的建立，整個流程一氣呵成，就像有個經驗豐富的 Senior 在旁邊協助\n🎯 上下文理解：它會記住我之前寫的程式碼風格和專案結構，新增的程式碼都能完美融入既有的架構中\n💡 智能補全：不只是簡單的語法補全，它會根據上下文給出完整的函式實作，甚至包含錯誤處理\n📝 文件生成：連 README、API 文件、註解都能自動生成，而且寫得比我還詳細（有點害羞 😅）\n\n最讓我驚嘆的是：整個開發流程變得非常「自然」，就像在跟一個很懂你的夥伴協作。以前寫 code 需要頻繁查文件、想語法，現在很多時候 AI 就直接給出了我要的答案。\n這種感覺就像從「手動檔」換到「自動檔」一樣 —— 你還是在開車，但整個過程變得更順暢、更專注在真正重要的邏輯思考上。\n\n我會不定期分享更多 VSCode + AI 開發的實戰體驗！ 🎉\n","categories":["vscodelife"],"tags":["java","vscode","github-copilot"]},{"title":"vscode+copilot開發心得","url":"/2025/09/14/vscode-copilot-thoughts/","content":"前言距離上一篇 使用 vscode+copilot 快速建立專案 已經快兩個月。這段時間我把以前的專案拿來當練手題，持續用 vscode 搭配 Copilot 做重構，最近算是到了一個階段性的里程碑，也比較有資格整理一下心得與體感。\n成果速覽先放結果：tinysocket。下面這張是目前 README.md 的截圖：\n\n\n\n\n文件撰寫體驗老實說，過去我非常不擅長寫說明文件——常常卡在措辭或結構。換上 vscode + Copilot 之後，整體心理阻力明顯下降。我只需要丟一句：替專案進行完整的分析並生成適合的文檔，它就會開始產出內容。雖然：\n\n產出的語氣常常有一種「過度熱情」或統一的 AI 風格。\n偶爾會出現 幻覺（虛構不存在的模組 &#x2F; 參數 &#x2F; 流程）。\n\n但在「快速產出草稿」這件事上，效率提升非常明顯。現在的流程變成：AI 出草稿 → 我做實際校驗與語氣調整 → 完成最終版本。整體投入的心力與時間成本都下降。\n重構與技術升級這次 tinysocket 從過去的 JDK 11 + Spring Boot 2，一次跳到 JDK 21 + Spring Boot 3。在重構過程中我順手調整了幾個長期想改的點：\n\nbuffer 的實作策略（記憶體使用與複用模型）\nprotocol 的註冊與擴充方式（模組化與可插拔）\nserver-side &#x2F; client-side 邏輯的職責切分\n\n整體代碼結構乾淨很多，開發迭代的節奏也更順。雖然還不到「vibe coding」那種一氣呵成的沉浸流暢，但 AI 輔助開發是實實在在幫助我產出想要的結果。這一次我沒有花太多時間鑽研 copilot-instructions.md 或 spec.md 的進階玩法——純粹以「自然互動」的使用模式，就已經有不錯的感受。更直接的感想：vscode + Copilot 的體驗完全碾壓 eclipse + Copilot。如果未來 Copilot 還是無法在 eclipse 深度整合，那我會建議乾脆直接轉陣 vscode。\n前端 Demo（AI 協作）我不擅長開發前端，也只略懂一點 JS。之前為了展示 tinysocket 的 websocket 使用情境，勉強刻過一個很陽春的 demo。這次升級時我把那個頁面也一起翻新。過程很簡單：我描述現有專案結構、想要的互動與狀態，Copilot 在幾分鐘內就給了一個「能跑、有基本結構與樣式」的版本。我後面再針對細節（排版 &#x2F; 邏輯微調 &#x2F; 錯誤處理）做修正。雖然不至於到震撼，但在第一次產出結果的瞬間，實際的衝擊感還是有的。\n以下是最後的 demo 截圖：\n\n\n單元測試與未來工作模式這次我沒有非常認真地補齊所有單元測試，但試著讓 Copilot 幫忙規劃測試場景與生產測試骨架。體感結論是：「單元測試 80% 可以交給 AI 先起頭」。透過自然語言描述：需求 → 邊界條件 → 例外情境，AI 就能快速鋪好一組測試檔。後續人類再專注在：\n\n釐清語意是否與實際需求一致\n補強 edge cases\n整合 CI &#x2F; coverage 門檻\n\n未來真的可能變成：測試從『手寫產出』轉為『審稿驗收』模式。\n結語簡單總結：工具與工作方式的生態正在快速轉變。AI 不是「取代」，而是把重構 &#x2F; 起稿 &#x2F; 模板化工作成本往下壓，讓我們把腦力留給系統設計、關鍵抽象與品質判斷。接下來我會再花些時間探索更進階的上下文餵養（如專案規格、角色化指令），之後如果有新的體驗，再寫一篇續集。 \n我們下次見。\n","categories":["vscodelife"],"tags":["java","vscode","github-copilot"]},{"title":"Windows Terminal主題配置","url":"/2020/03/09/windowsterminal-scheme/","content":"\n\n\n\n打開WindowsTerminal的Setting設置主題\nDracula主題\n&quot;profiles&quot;:[\t&#123;\t\t&quot;name&quot;: &quot;Windows PowerShell&quot;,\t\t&quot;commandline&quot;: &quot;powershell.exe&quot;,\t\t&quot;cursorColor&quot; : &quot;#657B83&quot;, // 光標顏色\t\t&quot;cursorShape&quot; : &quot;vintage&quot;, // 光標類型\t\t&quot;colorScheme&quot; : &quot;Dracula&quot;, // 配置主題\t\t&quot;fontFace&quot; : &quot;DejaVu Sans Mono for Powerline&quot;, // 字型\t\t&quot;fontSize&quot; : 12, // 字型大小\t\t&quot;hidden&quot;: false\t&#125;,\t&#123;\t\t&quot;name&quot;: &quot;cmd&quot;,\t\t&quot;commandline&quot;: &quot;cmd.exe&quot;,\t\t&quot;cursorColor&quot; : &quot;#657B83&quot;,\t\t&quot;cursorShape&quot; : &quot;vintage&quot;,\t\t&quot;colorScheme&quot; : &quot;Dracula&quot;,\t\t&quot;fontFace&quot; : &quot;DejaVu Sans Mono for Powerline&quot;,\t\t&quot;fontSize&quot; : 12,\t\t&quot;hidden&quot;: false\t&#125;],&quot;schemes&quot;:[\t&#123;\t\t&quot;name&quot; : &quot;Dracula&quot;,\t\t&quot;background&quot; : &quot;#282A36&quot;,\t\t&quot;black&quot; : &quot;#21222C&quot;,\t\t&quot;blue&quot; : &quot;#BD93F9&quot;,\t\t&quot;brightBlack&quot; : &quot;#6272A4&quot;,\t\t&quot;brightBlue&quot; : &quot;#D6ACFF&quot;,\t\t&quot;brightCyan&quot; : &quot;#A4FFFF&quot;,\t\t&quot;brightGreen&quot; : &quot;#69FF94&quot;,\t\t&quot;brightPurple&quot; : &quot;#FF92DF&quot;,\t\t&quot;brightRed&quot; : &quot;#FF6E6E&quot;,\t\t&quot;brightWhite&quot; : &quot;#FFFFFF&quot;,\t\t&quot;brightYellow&quot; : &quot;#FFFFA5&quot;,\t\t&quot;cyan&quot; : &quot;#8BE9FD&quot;,\t\t&quot;foreground&quot; : &quot;#F8F8F2&quot;,\t\t&quot;green&quot; : &quot;#50FA7B&quot;,\t\t&quot;purple&quot; : &quot;#FF79C6&quot;,\t\t&quot;red&quot; : &quot;#FF5555&quot;,\t\t&quot;white&quot; : &quot;#F8F8F2&quot;,\t\t&quot;yellow&quot; : &quot;#F1FA8C&quot;\t&#125;],","categories":["windows"],"tags":["windows","powershell","terminal"]}]