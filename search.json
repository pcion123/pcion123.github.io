[{"title":"Ubuntu安裝Docker","url":"/2021/08/21/docker-install/","content":"docker是目前容器化部屬最火紅的方案廢話不多說現在趕快來看看怎麼安裝吧!\n安裝$ sudo apt update$ sudo install docker.io\n\n\n\n查看版本# 查看版本$ docker versionClient: Version:           20.10.7 API version:       1.41 Go version:        go1.13.8 Git commit:        20.10.7-0ubuntu1~20.04.1 Built:             Wed Aug  4 22:52:25 2021 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Engine:  Version:          20.10.7  API version:      1.41 (minimum version 1.12)  Go version:       go1.13.8  Git commit:       20.10.7-0ubuntu1~20.04.1  Built:            Wed Aug  4 19:07:47 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.5.2-0ubuntu1~20.04.2  GitCommit: runc:  Version:          1.0.0~rc95-0ubuntu1~20.04.2  GitCommit: docker-init:  Version:          0.19.0  GitCommit:\n\n測試$ docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/\n\n補充如果我們希望docker可以用特定的user執行的話可以參照以下\n# 將用戶加入docker群組中$ sudo usermod -aG docker $USER# 套用新的群組設定$ sudo newgrp docker","categories":["docker"],"tags":["docker","ubuntu","linux"]},{"title":"Ubuntu安裝Codimd","url":"/2020/07/05/codimd-install/","content":"相關介紹githubmanual-deployment\n安裝nodejs# 安裝版本庫$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -# 安裝nodejs$ apt install -y nodejs# 查看nodejs版本$ node -v# 查看npm版本$ npm -v\n\n安裝相關依賴$ npm install -g yarn$ npm install -g node-gyp$ npm install -g sqlite3$ npm install -g webpack\n\n安裝codimd設置環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport PATH=$PATH:NODE_ENV=production\n\n抓取項目(&#x2F;opt)$ git clone https://github.com/hackmdio/codimd.git\n\n\n\n初始化配置先修改安裝配置bin&#x2F;setup\t.\t.\t.echo &quot;install packages&quot;npm install --production --unsafe-perm=true --allow-root\t.\t.\t.\n執行安裝配置$ sudo bash bin/setup\n\n修改環境配置編輯config.json\n&#123;\t.\t.\t.    &quot;production&quot;: &#123;        &quot;host&quot;: &quot;0.0.0.0&quot;, // 設置來源        &quot;port&quot;: 3000, // 設置port        &quot;loglevel&quot;: &quot;info&quot;,        &quot;hsts&quot;: &#123;            &quot;enable&quot;: true,            &quot;maxAgeSeconds&quot;: 31536000,            &quot;includeSubdomains&quot;: true,            &quot;preload&quot;: true        &#125;,        &quot;csp&quot;: &#123;            &quot;enable&quot;: true,            &quot;directives&quot;: &#123;            &#125;,            &quot;upgradeInsecureRequests&quot;: &quot;auto&quot;,            &quot;addDefaults&quot;: true,            &quot;addDisqus&quot;: true,            &quot;addGoogleAnalytics&quot;: true        &#125;,        &quot;db&quot;: &#123;            &quot;username&quot;: &quot;帳號&quot;, // 設置db帳號            &quot;password&quot;: &quot;密碼&quot;, // 設置db密碼            &quot;database&quot;: &quot;資料庫&quot;, // 設置資料庫名稱            &quot;host&quot;: &quot;localhost&quot;,            &quot;port&quot;: &quot;3306&quot;,            &quot;dialect&quot;: &quot;mysql&quot;        &#125;        &quot;linkifyHeaderStyle&quot;: &quot;gfm&quot;    &#125;&#125;\n\n編輯.sequelizerc\nvar path = require(&#x27;path&#x27;);module.exports = &#123;    &#x27;config&#x27;:          path.resolve(&#x27;config.json&#x27;),    &#x27;migrations-path&#x27;: path.resolve(&#x27;lib&#x27;, &#x27;migrations&#x27;),    &#x27;models-path&#x27;:     path.resolve(&#x27;lib&#x27;, &#x27;models&#x27;),    &#x27;url&#x27;:             &#x27;mysql://&#123;db帳號&#125;:&#123;db密碼&#125;@localhost:3306/codimd&#x27;&#125;\n\n編輯lib&#x2F;config&#x2F;default.js\n... allowAnonymous: false, // 關閉匿名登入 allowAnonymousEdits: false, // 關閉匿名編輯... email: true, // 開啟email使用 allowEmailRegister: true, // 允許email註冊...\n\n啟動$ npm run build // 重新編輯前端頁面$ node app.js // 啟動服務\n\n\n\n","categories":["linux"],"tags":["ubuntu","linux","codimd","hackmd"]},{"title":"Elasticsearch+Kibana+Logstash環境安裝","url":"/2019/10/20/elk-install/","content":"在分散式系統底下我們需要查詢log紀錄總不可能需要一台一台機器上去查看紀錄這個時候我們就會需要有個服務幫我們達成這個目的\nelasticsearch就很適合來幫我們完成這個任務\nelasticsearch官網\n\n\n安裝JDK請參考之前的文章\n\nelasticsearch佈署elasticsearch是一個分散式的儲存系統，屬於NoSQL資料庫的一種elasticsearch介紹\n#下載安裝檔$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-amd64.deb#下載驗證檔$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-amd64.deb.sha512#檢查檔案$ shasum -a 512 -c elasticsearch-7.4.0-amd64.deb.sha512#執行安裝$ sudo dpkg -i elasticsearch-7.4.0-amd64.deb\n\n修改配置檔案首先我們要先修改elasticsearch記憶體的使用量修改elasticsearch使用的記憶體，設定為主機的50%記憶體\n#/etc/elasticsearch/jvm.options-Xms1g  # Xms 記憶體使用下限-Xmx1g  # Xmx 記憶體使用上限\n\n修改設定檔#/etc/elasticsearch/elasticsearch.yml#設置服務名稱cluster.name: elk_elasticsearch#設置節點名稱node.name: elk_node#設置為主要結點node.master: true#允許節點儲存數據node.data: true#path.data: /var/lib/elasticsearch#path.logs: /var/log/elasticsearch#綁定來源network.bind_host: 0.0.0.0#綁定對外服務端口http.port: 9200#綁定節點通信端口transport.tcp.port: 9300#啟用資料壓縮transport.tcp.compress: true#集群發現節點列表discovery.seed_hosts: [&quot;127.0.0.1:9300&quot;]#設置主要節點列表cluster.initial_master_nodes: [&quot;127.0.0.1&quot;]\n\n測試#啟動服務$ service elasticsearch start#測試$ curl http://127.0.0.1:9200&#123;  &quot;name&quot; : &quot;elk_node&quot;,  &quot;cluster_name&quot; : &quot;elk_service&quot;,  &quot;cluster_uuid&quot; : &quot;SRb6b1RaTaewA_OK2C7fMA&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.4.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;deb&quot;,    &quot;build_hash&quot; : &quot;22e1767283e61a198cb4db791ea66e3f11ab9910&quot;,    &quot;build_date&quot; : &quot;2019-09-27T08:36:48.569419Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.2.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;\n\nkibana佈署kibana是elasticsearch可視化的重要元件kibana介紹\n#下載安裝檔$ wget https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-amd64.deb#下載驗證檔$ wget https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-amd64.deb.sha512#檢查檔案$ shasum -a 512 -c kibana-7.4.0-amd64.deb.sha512#執行安裝$ sudo dpkg -i kibana-7.4.0-amd64.deb\n\n修改配置檔案#/etc/kibana/kibana.yml#綁定對外服務端口server.port: 5601#綁定來源server.host: &quot;0.0.0.0&quot;#設置服務名稱server.name: &quot;elk_kibana&quot;#設置elasticsearch節點列表elasticsearch.hosts: [&quot;http://127.0.0.1:9200&quot;]#設置索引kibana.index: &quot;.kibana&quot;設置log路徑logging.dest: /var/log/kibana/kibana.log設置中文化i18n.locale: &quot;zh-CN&quot;\n\n建立log目錄#建立目錄$ mkdir /var/log/kibana#修改使用者權限$ chown kibana:kibana /var/log/kibana\n\n測試#啟動服務$ service kibana start\n測試網址http://127.0.0.1:5601\n\n\n\n\nlogstash佈署logstash是負責幫我們收集各種log資料的收集器logstash介紹\n#下載安裝檔$ wget https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.deb#下載驗證檔$ wget https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.deb.sha512#檢查檔案$ shasum -a 512 -c logstash-7.4.0.deb.sha512#執行安裝$ sudo dpkg -i logstash-7.4.0.deb\n\n修改配置檔案#/etc/logstash/conf.d/30-log.conf# Sample Logstash configuration for creating a simple# Beats -&gt; Logstash -&gt; Elasticsearch pipeline.input &#123;  beats &#123;    port =&gt; 5044  &#125;&#125;output &#123;  elasticsearch &#123;    hosts =&gt; [&quot;http://localhost:9200&quot;]    index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;    #user =&gt; &quot;elastic&quot;    #password =&gt; &quot;changeme&quot;  &#125;&#125;\n\n檢查設定檔$ /usr/share/logstash/bin/logstash --config.test_and_exit -f /etc/logstash/conf.d/30-log.conf...Configuration OK\n\n啟動服務#啟動服務$ service logstash start\n\n基本上elk環境安裝就到這裡之後有空再補上log server使用方式\n","categories":["elasticsearch"],"tags":["elasticsearch","kibana","logstash","佈署"]},{"title":"GitLab搭建與中文化","url":"/2018/03/23/gitlab-install/","content":"網路上已有蠻多類似的文章，我就不再過多的論述了就寫寫佈署的時一些問題就好\ngitlab佈署直接上官網gitlab官網gitlab中文社群\n我佈署的環境是virtualbox+ubuntu基本上照著官網的install指令去佈署就能成功佈署最新版本\n如果是要另外進行中文化的佈署就必需去中文社群看看有沒有對應的版本中文化社群\n例如我佈署的gitlab版本是8.8.9那我就需要找到中文化對應的版本p.s 版號只需要對應前兩個版號就可以了\n那該如何指定安裝指定的版號\n官網提供的安裝指令應該如下：\n$ sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; apt-get install gitlab-ee\n上面的指令其實是預先設定好gitlab指定的網址與安裝最新的版本不過我通常都把連線的網址都在佈署完成之後再另外設定所以我如果要安裝8.8.9的版本，那指令應該如下：\n$ sudo apt-get install gitlab-ee=8.8.9-ee.0\n安裝完成後再去更改external_url就好，更改路徑如下：\n/etc/gitlab/gitlab.rb\n設置連線配置\nexternal_url &#x27;http://127.0.0.1&#x27;\n最後再重新設定配置就完成了\n$ sudo gitlab-ctl reconfigure\n通常第一次登入會讓你重新設置root的密碼修改完再登入你就可以看到gitlab的歡迎畫面了\n\n\n如果只需要英文版本的那你看到這裡就行了接下來講講如何佈署成中文\ngitlab中文化第一步先用git clone整個中文開發項目\n$ git clone https://gitlab.com/larryli/gitlab.git\nclone下來之後就可以開始我們的中文化大業了\n# 先進入clone下來的項目中$ cd gitlab# 可以先看看所有版本的開發分支# git tag\n比對所有對應的本版分支\n$ sudo git diff v8.8.0..8.8.5.zh1 &gt; /tmp/8.8.diff\n停掉gitlab運行\n$ sudo gitlab-ctl stop\n應用中文化補丁\n$ sudo patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; /tmp/8.8.diff\n接下來就一直不斷enter到補丁完成，重新啟動gitlab\n$ sudo gitlab-ctl start\n重新登入之後就可看到熟悉的中文化介面\n","categories":["gitlab"],"tags":["佈署","gitlab","中文化"]},{"title":"Hello World","url":"/2018/03/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"安裝OpenJDK","url":"/2019/03/10/java-installopenjdk/","content":"安裝OpenJDK安裝預設版本OpenJDK\n$ sudo apt-get update$ sudo apt-get install default-jdk\n安裝指定版本OpenJDK\n$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk\n安裝指定版本OpenJRE\n$ sudo apt-get update$ sudo apt-get install openjdk-8-jre\n\n設定系統 Java 版本先查看當前有哪些版本可供設定\n$ update-alternatives --query java#或者$ update-alternatives --display java\n設定版本\n$ sudo update-alternatives --config java\n\n設置Java環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$JAVA_HOME/bin","categories":["java"],"tags":["java","jdk"]},{"title":"Jenkins搭建","url":"/2018/03/24/jenkins-install/","content":"要搭建jenkins需要安裝JDK，以下提供簡易安裝方式\n安裝OpenJDK安裝OpenJDK\n$ sudo apt-get update$ sudo apt-get install default-jdk\n\n\n\njenkins佈署jenkins官網\n基本上按照官方提供的方式安裝即可，首先添加套件金鑰\n$ wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -\n添加套件來源列表\n$ sudo sh -c &#x27;echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#x27;\n最後進行安裝\n$ sudo apt-get update$ sudo apt-get install jenkins\n修改連線配置(&#x2F;etc&#x2F;default&#x2F;jenkins)，基本上默認端口為8080\nHTTP_PORT=8080\n啟動腳本路徑(&#x2F;etc&#x2F;init.d&#x2F;jenkins)\n$ sudo bash /etc/init.d/jenkins  &#123;start|stop|status|restart|force-reload&#125;\n另外也可以這樣\n$ sudo service jenkins  &#123;start|stop|status|restart|force-reload&#125;\n啟動之後需要設置初始密碼\n$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword9b4e46e0c33e4e99b9bbc916a7adccac\n輸入初始密碼\n\n選擇預設插件集合\n\n等待初始化完成\n\n最後再建立管理者帳號就大功告成了\n","categories":["jenkins"],"tags":["佈署","jenkins"]},{"title":"Jenkins + Gitlab + Maven + JDK 設定","url":"/2018/03/29/jenkins-setting/","content":"在jenkins安裝好後還需要一些進一步的設定，才能讓其他工具好好運作，下面我們就開始做完這些設定\n\n\n進入jenkins設定\n\n\n進入Global Tool Configuration\n\n\n設置你的JDK安裝路徑\n\n\n設置你的GIT安裝路徑\n\n\n設置你的MAVEN安裝路徑\n\n\n接下來生成SSL金鑰，如果已經有了可以跳過這一步\n$ ssh-keygen -t rsa -C\n接下來去Credentials設置SSL連線配置\n\n\n最後我們要去把jenkins的系統權限加入到root裡面，不然他在跑shell會有權限問題\n將jenkins帳號加入root群組中\n$ sudo gpasswd -a root jenkins\n修改jenkins文件\n$ sudo nano /etc/default/jenkins\n修改文件中這兩行\nJENKINS_USER=rootJENKINS_GROUP=root\n完成這些設定就大功告成啦!\n","categories":["jenkins"],"tags":["gitlab","jdk","jenkins","maven"]},{"title":"解決Jenkins執行sudo命令出現錯誤","url":"/2019/03/10/jenkins-sudoerror/","content":"我們在使用jenkins部屬任務的時候常常需要使用到腳本，如果在腳本中使用到了sudo這個令命時，有可能會產生以下錯誤：\nsudo: no tty present and no askpass program specified\n\n解决方式：在jenkins host server上執行以下命令：\n$ sudo visudo\n在末尾加入：\njenkins ALL=(ALL) NOPASSWD: ALL\nCtrl+O 存檔(ps.存檔的時候副檔名不要加入.tmp，這樣即可覆蓋原來的檔案)Ctrl+X 離開\n最後重啟jenkins\n$ sudo bash /etc/init.d/jenkins restart#另外也可以這樣$ sudo service jenkins restart\n\n最後再重新建構一次任務即可\n","categories":["jenkins"],"tags":["jenkins","error"]},{"title":"Jenkins + Gitlab + Tomcat 自動化部署","url":"/2018/03/29/jenkins-work/","content":"前面做這麼多都是為了現在做準備，假設我們的workflow\n程式更新代碼至gitlab -&gt; 企劃或者anyone按個按鍵 -&gt; jenkins自動幫你完成專案更新代碼並重新佈署\n這樣我們可以減少人力去處理這些雜事更能專心再業務處理的需求上下面就來看看怎麼完成這些設定\n\n\n新增作業\n\n\n填好項目名稱並選擇free-style\n\n\n這步驟是讓你自訂workspace路徑，不設定就會是預設項目路徑\n\n\n填入你的項目git來源，並使用之前設定好的ssl連線憑證\n\n\n選擇maven作為項目打包工具並填入相關腳本指令之後在執行shell script把maven打包好的檔案轉移至tomcat目錄底下在啟動tomcat\n\n\n儲存好相關設置之後再執行建置\n\n\n一切就自動化部署完成了!\n","categories":["jenkins"],"tags":["gitlab","jenkins","tomcat"]},{"title":"Kubernetes 控制元件介紹","url":"/2025/10/04/kubernetes-controller-intro/","content":"Kubernetes 控制元件介紹在 Kubernetes 中，我們需要控制平面 (Control Plane) 來管理 Node 的運行狀態。接下來我們將介紹 Node 是如何被管理的，以及各個控制元件的功能。\n整體架構概述Kubernetes 採用 Master-Worker 架構模式：\n\nControl Plane (Master): 負責管理整個叢集的決策和控制\nWorker Nodes: 負責執行實際的應用程式工作負載\n\n\n\n\n\n\nNode ComponentsNode Components 是每個 Worker Node 必須具備的核心元件：\n\nContainer Runtime: 負責管理容器的生命週期，包括容器的建立、執行和銷毀\nkubelet: 作為 Node 的代理程式，負責建立 Pod 並維護容器的健康狀態\nkube-proxy: 負責處理 Node 的網路代理功能，實現服務發現和負載平衡\n\nControl Plane Components控制平面負責管理整個 Kubernetes 叢集中所有的 Node Components。以下是控制平面的核心元件：\n\nkube-api-server: 作為 Kubernetes API 的前端，負責處理來自客戶端的請求，經過驗證和授權後，將請求轉發給對應的元件\nkube-scheduler: 負責將 Pod 調度到適合的 Node 上執行，會根據資源可用性、硬體需求等條件來選擇最佳的 Node\nkube-controller-manager: 執行各種控制器，負責監控 Kubernetes 叢集的狀態變化並確保達到期望狀態\netcd: 分散式的 key-value 儲存系統，用來儲存 Kubernetes 叢集的所有配置資料和狀態資訊\ncloud-controller-manager: 負責與雲端服務提供商進行整合的元件，它可以幫助 Kubernetes 連接公有雲平台，使用雲端服務的 API 來管理雲端資源\n\n\n提示etcd 採用分散式架構設計，因此在一個 Kubernetes 叢集中可以同時部署多個 Control Plane 元件來實現高可用性\n\n\n提示cloud-controller-manager 僅在雲端環境中才會部署，如果 Kubernetes 叢集運行在本地環境則不會包含此元件（例如：minikube）\n\n為了確保服務的高可用性，生產環境的 Kubernetes 通常會部署兩個以上的 Control Plane 節點。\n元件間的通訊機制所有元件之間的通訊都必須透過 kube-api-server 進行，它是整個 Kubernetes 架構的核心通訊樞紐：\n\nkubelet 透過 API Server 回報 Node 和 Pod 的狀態\nController Manager 透過 API Server 監控叢集狀態\nScheduler 透過 API Server 獲取調度資訊並做出調度決策\n所有配置和狀態資料都儲存在 etcd 中，只有 API Server 能直接存取\n\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes 核心元件介紹","url":"/2025/09/28/kubernetes-core-intro/","content":"Kubernetes 核心元件介紹架構總覽\n\n上圖展示了 Kubernetes 完整架構，包含控制平面、工作節點、服務層和配置管理等核心元件及其互動關係\n\n\n\nPodKubernetes 中的最小運行單位\n\n每個 Pod 都會被分配一個唯一的虛擬 IP 位址\nContainer: Pod 內運行的應用程式容器，雖然每個 Pod 可以運行多個容器，但通常建議只運行一個主要容器\n\nNodeKubernetes 叢集的工作節點\n\n可以是實體機器或虛擬機器\n多個 Node 組成 Kubernetes 叢集，提供運算資源\n\nService提供穩定的網路端點\n\n解決 Pod 重啟時 IP 位址變動的問題\n提供固定的 IP 位址和 DNS 名稱，作為 Pod 群組的存取入口\n分為兩種類型：\n內部 Service: 僅供叢集內部通訊使用\n外部 Service: 允許外部流量存取\n\n\n\nIngressHTTP&#x2F;HTTPS 路由管理\n\n提供域名對應服務，讓外部用戶能透過網域名稱存取 Service\n支援 SSL&#x2F;TLS 憑證管理和負載平衡\n\nConfigMap應用程式配置管理\n\n儲存非敏感的配置資料（如設定檔、環境變數）\n避免因配置變更而重新建置映像檔，減少部署停機時間\n支援熱更新配置\n\n\n警告ConfigMap 以明文方式儲存內容，請勿存放敏感資料\n\nSecret敏感資料安全儲存\n\n專門用於儲存機敏資料（如密碼、API 金鑰、憑證）\n資料以 Base64 編碼格式儲存\n提供比 ConfigMap 更高的安全性\n\n\n註解Secret 使用 Base64 編碼儲存資料，並可與 Pod 安全地共享\n\nVolumes持久化資料儲存\n\n解決容器重啟時資料遺失的問題\n提供多種儲存類型（本機儲存、網路儲存、雲端儲存）\n確保重要資料在 Pod 生命週期外持續保存\n\nDeployment無狀態應用程式的部署管理\n\n管理 Pod 的部署、更新和擴縮容\n提供聲明式更新，確保應用程式的期望狀態\n支援滾動更新（Rolling Update）和回滾功能\n適用於無狀態的應用程式，如網頁伺服器、API 服務\n主要功能：\n副本管理: 確保指定數量的 Pod 副本正常運行\n自動修復: 當 Pod 異常時自動重新建立\n版本控制: 追蹤部署歷史，支援快速回滾\n零停機部署: 透過滾動更新實現無中斷服務更新\n\n\n\n\n提示Deployment 是部署無狀態應用程式的首選方式，提供了強大的生命週期管理功能\n\nStatefulSet有狀態應用程式的部署管理\n\n專門用於管理有狀態的應用程式，如資料庫、訊息佇列\n為每個 Pod 提供穩定且唯一的網路識別符\n保證 Pod 的有序部署、擴縮容和終止\n提供持久化儲存與 Pod 的穩定綁定關係\n主要特色：\n穩定的網路識別: 每個 Pod 都有固定的主機名稱（如 pod-0, pod-1）\n有序部署: Pod 按照順序建立，確保前一個 Pod 就緒後才建立下一個\n持久儲存: 每個 Pod 都有專屬的持久化儲存卷\n有序終止: 刪除時按照相反順序進行，確保資料完整性\n\n\n\n\n重要提示StatefulSet 適用於需要穩定儲存和網路識別的應用程式，如 MySQL、MongoDB、Kafka 等\n\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"Kubernetes Namespace 使用指南","url":"/2025/10/10/kubernetes-namespace/","content":"Kubernetes Namespace 使用指南什麼是 Namespace？Kubernetes Namespace 是一個 API 物件，用於在 Kubernetes 叢集中創建虛擬的資源隔離環境。Namespace 提供了一種將叢集資源劃分為多個獨立區域的方式，讓不同的團隊、專案或環境可以在同一個叢集中安全地共存。\nNamespace 的主要功能：\n資源隔離：將不同的應用程式或環境分隔在不同的命名空間中\n存取控制：透過 RBAC 實現細粒度的權限管理\n資源配額管理：限制每個命名空間可使用的叢集資源量\n名稱空間管理：避免資源名稱衝突，支援相同名稱的資源存在於不同命名空間\n\n為什麼使用 Namespace？相較於將所有資源都放在預設命名空間中，Namespace 提供了更好的資源管理方式：\n\n多租戶支援：讓多個團隊或專案安全地共享同一個 Kubernetes 叢集\n環境分離：清楚區分開發、測試、生產等不同環境的資源\n資源管理：透過資源配額控制每個環境的資源使用量\n權限控制：實現精細的存取權限管理，提升安全性\n\n\n\n\n預設 NamespaceKubernetes 叢集預設會創建四個系統命名空間：\n\nkube-system: 存放 Kubernetes 系統元件，如 kube-dns、kube-proxy、etcd 等核心服務\nkube-public: 公開可讀的命名空間，通常用於存放叢集資訊，所有使用者（包括未認證使用者）都可以讀取\nkube-node-lease: 用於 Node 租約物件，幫助確定 Node 的可用性和健康狀態\ndefault: 預設命名空間，當沒有指定命名空間時，資源會被創建在這裡\n\n建立自定義 Namespace方法一：使用 YAML 檔案建立建立 dockertest-namespace.yaml 檔案：\napiVersion: v1kind: Namespacemetadata:  name: dockertest-namespace  labels:    name: dockertest-namespace    environment: dev\n\n套用設定檔：\nkubectl create -f dockertest-namespace.yaml\n\n\n\n方法二：使用指令直接建立kubectl create namespace dockertest-namespace\n\n檢視所有 Namespacekubectl get namespaces# 或使用簡寫kubectl get ns\n\n在指定 Namespace 中操作資源在特定 Namespace 建立資源# 在指定的 namespace 中建立 podkubectl run nginx --image=nginx -n dockertest-namespace# 使用 YAML 檔案建立資源到指定 namespacekubectl apply -f dockertest-deployment.yaml -n dockertest-namespace\n\n\n\n設定預設 Namespace# 設定當前 context 的預設 namespacekubectl config set-context --current --namespace=dockertest-namespace# 確認目前的 context 設定kubectl config view --minify | grep namespace\n\n\n\n檢視 Namespace 中的資源# 檢視指定 namespace 中的所有 podkubectl get pods -n dockertest-namespace# 檢視所有 namespace 中的 podkubectl get pods --all-namespaces# 檢視 namespace 的詳細資訊kubectl describe namespace dockertest-namespace\n\n\n\n刪除 Namespace注意：刪除 Namespace 會同時刪除該命名空間內的所有資源！\nkubectl delete namespace dockertest-namespace\n\n\n\n資源配額管理為 Namespace 設定資源限制，避免某個環境消耗過多叢集資源：\napiVersion: v1kind: ResourceQuotametadata:  name: compute-quota  namespace: dockertest-namespacespec:  hard:    requests.cpu: &quot;4&quot;    requests.memory: 8Gi    limits.cpu: &quot;8&quot;    limits.memory: 16Gi    persistentvolumeclaims: &quot;10&quot;    pods: &quot;10&quot;\n\n最佳實踐建議\n環境分離：為不同環境（開發、測試、生產）建立獨立的命名空間\n團隊隔離：為不同團隊或專案建立專用的命名空間\n命名規範：採用一致的命名規範，如 team-environment 格式\n資源配額：為每個命名空間設定合適的資源配額\n權限控制：結合 RBAC 實現細粒度的權限管理\n監控標籤：為命名空間加上有意義的標籤，便於監控和管理\n\n範例命名建議：\n\nfrontend-dev、frontend-prod\nbackend-staging、backend-prod\nteam-alpha-dev、team-beta-prod\n\n","categories":["kubernetes"],"tags":["kubernetes"]},{"title":"設置Linux環境變數","url":"/2019/03/10/linux-environmentvariables/","content":"我們在進行環境開發的時候常常需要用到一些系統路徑，那這些路徑我們可以用系統的環境變數來讓他大大縮減打字的長度，以下就介紹我們如何來建立這些環境變數\nlinux提供兩種設置環境變數的方式 -&gt; 使用者環境變數 &amp; 系統環境變數\n\n\n使用者環境變數使用者環境變數儲存在以下檔案中：~&#x2F;.profile~&#x2F;.bashrc~&#x2F;.bash_profile~&#x2F;.bash_login\n系統環境變數系統環境變數儲存在以下檔案中：&#x2F;etc&#x2F;profile&#x2F;etc&#x2F;profile.d&#x2F;etc&#x2F;bash.bashrc\n加入系統環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport JAVA_HOME=/usr/lib/jvm/jdk1.7.0export PATH=$PATH:$JAVA_HOME/bin\n\n環境變數更改後,將在使用者下次登陸時生效如果想立刻生效,則執行下面的語句\n$ source /etc/profile\n\n生效後我們可以進行測試\n$ echo $JAVA_HOME\n\n成功後應當看到剛剛我們我設置的路徑另外如果想查看當前系統所設置的路徑有哪些可以輸入：\n$ echo $PATH\n他會顯示當前所有的環境路徑有哪些\n","categories":["linux"],"tags":["linux","環境變數"]},{"title":"安裝Maven","url":"/2019/03/16/maven-install/","content":"安裝Maven先下載maven：\n$ wget https://www-us.apache.org/dist/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz\n解開包:\n$ tar xzvf apache-maven-3.6.0-bin.tar.gz\n移動到&#x2F;opt&#x2F;底下：\n$ mv apache-maven-3.6.0-bin /opt\n\n設置Maven環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport MAVEN_HOME=/opt/apache-maven-3.6.0export M2_HOME=/opt/apache-maven-3.6.0export PATH=$PATH:$MAVEN_HOME/binexport PATH=$PATH:$M2_HOME/bin","categories":["maven"],"tags":["linux","maven"]},{"title":"Ubuntu安裝Minikube (2025)","url":"/2025/09/23/minikube-install-2025/","content":"在現代容器化開發環境中，Minikube 是學習和測試 Kubernetes 的絕佳工具。本文將詳細介紹如何在 Ubuntu 24.04.3 LTS 上完整建置 Minikube 環境，包含 Docker 容器引擎、kubectl 命令列工具，以及完整的 Tomcat 服務部署範例。\n無論您是 Kubernetes 初學者還是需要本地開發環境的工程師，這篇指南都將協助您快速建立一個功能完整的本地 Kubernetes 集群。\n環境需求\n作業系統: Ubuntu 24.04.3 LTS\n記憶體: 建議至少 4GB RAM\n硬碟空間: 建議至少 20GB 可用空間\n網路: 可存取網際網路進行套件下載\n\n\n\n第一步：系統前置準備在開始安裝之前，我們需要更新系統套件並安裝必要的基礎工具。這些工具將為後續的 Docker 和 Kubernetes 組件安裝提供支援。\n# 更新系統套件資料庫並升級現有套件sudo apt update &amp;&amp; sudo apt upgrade -y# 安裝必要的基礎工具# curl: 用於下載檔案# wget: 另一個下載工具# apt-transport-https: 支援 HTTPS 來源# ca-certificates: 憑證管理# software-properties-common: 軟體來源管理# conntrack: Kubernetes 網路追蹤所需sudo apt install -y curl wget apt-transport-https ca-certificates software-properties-common conntrack\n\n第二步：安裝 Docker 容器引擎Docker 是 Minikube 的容器運行時環境。Minikube 支援多種容器引擎，但 Docker 是最常用且穩定的選擇。\n# 安裝 Docker 社群版本sudo apt install -y docker.io# 啟動 Docker 服務並設定為開機自動啟動sudo systemctl enable --now docker# 將目前使用者加入 docker 群組，避免每次都需要 sudosudo usermod -aG docker $USER\n\n這一步完成後需要 重新登入系統 或執行 newgrp docker 讓群組變更生效。\n\n重要提醒: 將使用者加入 docker 群組可以避免每次執行 Docker 指令時都需要 sudo 權限，但請注意這會給予該使用者等同 root 的權限來操作 Docker。\n\n# 驗證 Docker 安裝是否成功docker version\n\n第三步：安裝 kubectl 命令列工具kubectl 是 Kubernetes 的官方命令列工具，用於與 Kubernetes 集群進行互動。它可以讓我們管理 Pod、Service、Deployment 等各種 Kubernetes 資源。\n# 取得最新穩定版本的版本號$KUBECTL_VER=$(curl -L -s https://dl.k8s.io/release/stable.txt)# 下載對應版本的 kubectl 執行檔curl -LO &quot;https://dl.k8s.io/release/$KUBECTL_VER/bin/linux/amd64/kubectl&quot;# 賦予執行權限chmod +x kubectl# 移動到系統執行路徑sudo mv kubectl /usr/local/bin/# 驗證 kubectl 安裝是否成功kubectl version --client\n\n第四步：安裝並設定 MinikubeMinikube 是一個輕量級的 Kubernetes 實作，設計用於在本地環境運行單節點的 Kubernetes 集群。它非常適合開發、測試和學習 Kubernetes。\n基礎安裝# 下載最新版本的 Minikubecurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64# 安裝到系統執行路徑sudo install minikube-linux-amd64 /usr/local/bin/minikube# 驗證 Minikube 安裝是否成功minikube version\n\n以下是 Minikube 的常用操作指令，建議先熟悉這些基本指令：\n# 查看 Minikube 版本資訊minikube version# 查看目前集群狀態minikube status# 啟動 Kubernetes 集群minikube start# 停止集群（保留資料）minikube stop\n\n啟動 Minikube 集群在完成安裝後，我們可以開始啟動並測試 Minikube 集群：\n\n啟動minikube\n\n# 使用 Docker 作為容器引擎啟動集群minikube start --driver=docker# 啟動集群並指定特定的 Kubernetes 版本minikube start --driver=docker --kubernetes-version=v1.29.0\n\n\n建立外部存取代理\n\n# 建立代理連線，允許外部存取 Kubernetes APIkubectl proxy --address=&#x27;0.0.0.0&#x27; --disable-filter=true\n\n\n注意: 此指令會在背景持續運行，建議在新的終端視窗中執行\n\n\n\n\n存取 Kubernetes Dashboard\n\n# 啟動 Web 介面儀表板並取得存取網址minikube dashboard --url\n\n此指令會輸出一個網址，您可以在瀏覽器中開啟此網址來存取 Kubernetes 的視覺化管理介面。\n\n\n查看dashboard實際運行結果\n\n\n實戰範例：部署 Tomcat 應用程式為了驗證 Minikube 環境運作正常，我們將部署一個完整的 Tomcat Web 應用程式作為示範。\n步驟一：啟用 Ingress 控制器# 啟用 Ingress 控制器附加元件minikube addons enable ingress# 等待 Ingress 控制器 Pod 準備完成kubectl -n ingress-nginx get pods -l app.kubernetes.io/component=controller -w\n\n\n提示: 使用 -w 參數可以持續監看 Pod 狀態變化，看到 Running 狀態時按 Ctrl+C 退出\n\n步驟二：準備 Kubernetes YAML 配置檔以下是一個完整的 Tomcat 部署配置，包含 Deployment、Service 和 Ingress 三個資源：\napiVersion: apps/v1kind: Deploymentmetadata:  name: tomcat-deploymentspec:  replicas: 1  selector:    matchLabels:      app: tomcat  template:    metadata:      labels:        app: tomcat    spec:      containers:      - name: tomcat        image: tomcat:10.1-jdk17        ports:        - containerPort: 8080        command: [&quot;/bin/sh&quot;,&quot;-c&quot;]        args:          - cp -r /usr/local/tomcat/webapps.dist/ROOT /usr/local/tomcat/webapps/ &amp;&amp; exec catalina.sh run        readinessProbe:          httpGet:            path: /            port: 8080          initialDelaySeconds: 10          periodSeconds: 5---apiVersion: v1kind: Servicemetadata:  name: tomcat-servicespec:  type: ClusterIP  selector:    app: tomcat  ports:    - name: http      port: 8080      targetPort: 8080---apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: tomcat-ingressspec:  ingressClassName: nginx  rules:  - http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: tomcat-service            port:              number: 8080\n\n步驟三：部署服務到集群# 部署 YAML 配置到集群kubectl apply -f tomcat.yaml# 查看 Pod 運行狀態kubectl get pods# 查看所有相關資源狀態kubectl get deployment,service,ingress\n\n驗證服務是否正常運行：\n# 取得 Minikube 集群 IP 位址$MINIKUBE_IP=$(minikube ip)# 查看 Minikube IPecho &quot;Minikube IP: $MINIKUBE_IP&quot;\n\n現在可以在瀏覽器中開啟 http://$MINIKUBE_IP 來查看 Tomcat 歡迎頁面。\n\n\nVirtualBox 環境特殊設定如果您是在 VirtualBox 虛擬機中運行 Ubuntu Server，需要進行額外的網路設定以便從主機存取服務。\nSSH 隧道設定由於 VirtualBox NAT 網路的限制，我們需要建立 SSH 隧道來橋接主機與虛擬機內的服務：\n# 建立 SSH 隧道，將主機的 18080 埠轉發到 Minikube 的 80 埠# 假設您的 SSH 服務運行在虛擬機的 2222 埠上ssh -N -L 18080:$MINIKUBE_IP:80 -p 2222 $USER@127.0.0.1\n\n參數說明：\n\n-N: 不執行遠端指令，僅用於建立隧道\n-L 18080:$MINIKUBE_IP:80: 將本機 18080 埠轉發到目標的 80 埠\n-p 2222: SSH 服務埠號\n$USER@127.0.0.1: 使用者名稱和虛擬機位址\n\n設定完成後，您就可以在 Windows 主機的瀏覽器中輸入 http://localhost:18080 來存取 Tomcat 服務。\nVirtualBox NAT 設定確保您的 VirtualBox 虛擬機網路設定如下：\n\n網路介面卡設定為 NAT 模式\n進階設定中開啟埠轉發規則：\n\n\n\n網路架構圖下圖展示了完整的 Minikube + Tomcat + Ingress 網路架構：\n\n\n總結本文詳細介紹了在 Ubuntu 24.04.3 上建置 Minikube 開發環境的完整流程，包含：\n主要完成項目\n系統環境準備 - 安裝必要的基礎套件和工具\nDocker 容器引擎 - 作為 Minikube 的容器運行時\nkubectl 工具 - Kubernetes 的命令列管理介面\nMinikube 本機集群 - 單節點 Kubernetes 環境\n完整應用部署 - Tomcat Web 服務的實際範例\nIngress 控制器 - 處理外部流量的入口管理\nVirtualBox 整合 - 虛擬機環境下的網路設定\n\n下一步建議完成本教學後，您可以：\n\n嘗試部署其他類型的應用程式（如 MySQL、Redis 等）\n學習 Kubernetes 的進階概念（ConfigMap、Secret、PersistentVolume）\n探索 Minikube 的其他附加元件（Metrics Server、Dashboard 等）\n實驗不同的部署策略（Rolling Update、Blue-Green Deployment）\n\n常見問題排除\n如果遇到資源不足的問題，可以調整 Minikube 的記憶體和 CPU 配置\n若服務無法存取，請檢查防火牆設定和網路配置\nDocker 權限問題請確認使用者是否已加入 docker 群組\n\n透過這個環境，您已經具備了本地 Kubernetes 開發的基礎設施，可以開始探索容器編排和微服務架構的精彩世界。\n","categories":["kubernetes"],"tags":["docker","ubuntu","linux","kubernetes","minikube"]},{"title":"Ubuntu安裝Minikube","url":"/2021/08/21/minikube-install/","content":"繼上次的docker安裝今天要繼續部屬kubernetes的內容\n簡介minikube是由google開發的精簡版kubernetes工具可以簡單的模擬k8s底下的環境運作\n\n\n安裝容器kubernetese提供多樣的容器部屬環境這邊我們選用docker當作容器的底層\n請參考之前的文章\n\n安裝kubectlkubectl是一套管理kubernetes的命令工具\n安裝# 更新套件管理$ sudo apt update# 安裝套件倉庫$ sudo apt install -y apt-transport-https ca-certificates curl# 下載倉庫憑證$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg# 加入憑證信任列表$ echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main# 更新套件管理$ sudo apt update# 安裝kubectl$ sudo apt install kubectl -y\n\n查看版本$ kubectl version --short --clientClient Version: v1.22.1\n\n安裝minikube現在開始安裝主角\n安裝# 下載安裝包$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb# 安裝套件$ sudo dpkg -i minikube_latest_amd64.debSelecting previously unselected package minikube.(Reading database ... 71806 files and directories currently installed.)Preparing to unpack minikube_latest_amd64.deb ...Unpacking minikube (1.22.0-0) ...Setting up minikube (1.22.0-0) ...\n\n查看版本$ minikube versionminikube version: v1.22.0commit: a03fbcf166e6f74ef224d4a63be4277d017bb62e\n\n啟動$ minikube start😄  minikube v1.22.0 on Ubuntu 20.04 (vbox/amd64)✨  Automatically selected the docker driver. Other choices: ssh, none👍  Starting control plane node minikube in cluster minikube🚜  Pulling base image ...💾  Downloading Kubernetes v1.21.2 preload ...    &gt; preloaded-images-k8s-v11-v1...: 502.14 MiB / 502.14 MiB  100.00% 7.08 MiB    &gt; gcr.io/k8s-minikube/kicbase...: 361.08 MiB / 361.09 MiB  100.00% 3.95 MiB🔥  Creating docker container (CPUs=2, Memory=2200MB) ...🐳  Preparing Kubernetes v1.21.2 on Docker 20.10.7 ...    ▪ Generating certificates and keys ...    ▪ Booting up control plane ...    ▪ Configuring RBAC rules ...🔎  Verifying Kubernetes components...    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5🌟  Enabled addons: storage-provisioner, default-storageclass🏄  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default\n\n啟動dashboard正常的kubernetes的dashboard需要另外安裝的但是minikube已經自帶dashboard套件只需啟動就行了\n$ minikube dashboard🔌  Enabling dashboard ...    ▪ Using image kubernetesui/dashboard:v2.1.0    ▪ Using image kubernetesui/metrics-scraper:v1.0.4🤔  Verifying dashboard health ...🚀  Launching proxy ...🤔  Verifying proxy health ...🎉  Opening http://127.0.0.1:33657/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...👉  http://127.0.0.1:33657/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/\n\n開啟proxy一般來說啟動dashboard就會自動幫你開啟瀏覽器到dashboard的頁面中了但是筆者的環境是裝在virtualbox的ubuntu-server底下所以就需要另外提供外連的方式了\n$ kubectl proxy --address=&#x27;0.0.0.0&#x27; --port=8001 --accept-hosts=&#x27;^*$&#x27;Starting to serve on [::]:8001\n\n這樣就大功告成啦!\n\n\n補充安裝過程設定如果出了什麼問題想要重置我們可刪掉整個minikube設置重來\n# 刪除minikube環境$ minikube delete &amp;&amp; rm -rf ~/.minikube# 重啟minikube$ minikube start","categories":["kubernetes"],"tags":["docker","ubuntu","linux","kubernetes","minikube"]},{"title":"Ubuntu安裝Nexus","url":"/2021/09/25/nexus-install/","content":"安裝JDK請參考之前的文章\n\n下載nexus官方下載或者nexus-3.33.1-01-unix\n\n\n建立nexus使用者建立nexus專用的系統帳號\n$ useradd -M -d /opt/nexus -s /bin/bash -r nexus\n允許nexus用戶可以使用無密碼的sudo運行命令\n$ echo &quot;nexus   ALL=(ALL)       NOPASSWD: ALL&quot; &gt; /etc/sudoers.d/nexus\n\n安裝nexus先建立nexus目錄\n$ mkdir /opt/nexus\n解開nexus到剛剛建立好的目錄底下\n$ tar -zxvf nexus-3.33.1-01-unix.tar.gz -C /opt/nexus --strip-components=1\n修改權限\n$ chown -R nexus: /opt/nexus\n\n修改配置調整nexus內存大小調整自身機器合適的大小,這邊測試調整成2G\n開啟&#x2F;opt&#x2F;nexus&#x2F;bin&#x2F;nexus.vmoptions\n-Xms2048m-Xmx2048m-XX:MaxDirectMemorySize=2048m...\n\n調整nexus相對路徑因為剛剛解開nexus的時候把sonatype-work目錄的位置移上了一層所以這邊相對路徑就需要調整一下\n開啟&#x2F;opt&#x2F;nexus&#x2F;bin&#x2F;nexus.vmoptions\n...-XX:LogFile=./sonatype-work/nexus3/log/jvm.log...-Dkaraf.data=./sonatype-work/nexus3-Dkaraf.log=./sonatype-work/nexus3/log-Djava.io.tmpdir=./sonatype-work/nexus3/tmp\n\n修改nexus運行帳號修改nexus運行時使用帳號請修改成剛剛專門建立的帳號\n開啟&#x2F;opt&#x2F;nexus&#x2F;bin&#x2F;nexus.rc\nrun_as_user=&quot;nexus&quot;\n\n修改nexus對外port預設port是8081如果不需要調整請跳過這一步因為測試環境的關係這邊改成9090\n開啟&#x2F;opt&#x2F;nexus&#x2F;etc&#x2F;nexus-default.properties\n## DO NOT EDIT - CUSTOMIZATIONS BELONG IN $data-dir/etc/nexus.properties### Jetty sectionapplication-port=9090application-host=0.0.0.0\n\n啟動nexus啟動服務啟動\n$ sudo -u nexus /opt/nexus/bin/nexus start\n監看log監看log\n$ tail -f /opt/nexus/sonatype-work/nexus3/log/nexus.log\n\n第一次登入會看到以下畫面,預設帳號為admin\n\n\n獲取密碼獲取第一次登入密碼\n$ cat /opt/nexus/sonatype-work/nexus3/admin.password\n\n初始設定1.修改管理者密碼2.根據需求調整,這邊我選擇關閉匿名用戶登入3.關閉問題回饋\n\n登入後做完第一次設定後服務就正式裝好啦!\n\n\n系統服務建立腳本建立&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nexus.service\n[Unit]Description=nexus serviceAfter=network.target[Service]Type=forkingLimitNOFILE=65536ExecStart=/opt/nexus/bin/nexus startExecStop=/opt/nexus/bin/nexus stopUser=nexusRestart=on-abort[Install]WantedBy=multi-user.target\n\n重載systemd$ systemctl daemon-reload\n\n啟用服務$ systemctl enable --now nexus.service\n\n查看服務狀態$ systemctl status nexus.service\n\n服務正常運行,這樣我們以後就可以透過systemctl管理服務了\nroot@pcionserver:/etc/systemd/system# root@pcionserver:/etc/systemd/system# systemctl status nexus.service● nexus.service - nexus service     Loaded: loaded (/etc/systemd/system/nexus.service; enabled; vendor preset: enabled)     Active: active (running) since Sat 2021-09-25 07:51:16 UTC; 6min ago    Process: 8292 ExecStart=/opt/nexus/bin/nexus start (code=exited, status=0/SUCCESS)   Main PID: 8486 (java)      Tasks: 80 (limit: 4616)     Memory: 1.3G     CGroup: /system.slice/nexus.service             └─8486 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java -server -Dinstall4j.jvmDir=/usr/lib/jvm/java-8-openjdk-amd64/jre -Dexe4j.moduleName=/opt/nexus/bin/nexus -XX:+UnlockDiag&gt;Sep 25 07:51:16 pcionserver systemd[1]: Starting nexus service...Sep 25 07:51:16 pcionserver nexus[8292]: Starting nexusSep 25 07:51:16 pcionserver systemd[1]: Started nexus service.","categories":["maven"],"tags":["linux","maven","nexus"]},{"title":"安裝Nginx","url":"/2020/11/14/nginx-install/","content":"安裝Nginx$ apt install nginx\n\nconfig路徑# 查詢config路徑$ nginx -t# ubuntu預設會在/etc/nginx底下\n\n基本指令# 啟動nginx$ systemctl start nginx# 停止ngnix$ systemctl stop nginx# 重載ngnix$ systemctl reload nginx\n\n\n\n頁面測試 http://127.0.0.1\n\n以下內容偏向心得筆記\n設定proxyserver &#123;\t# 監聽 80 port    listen 80;    listen [::]:80;    # 設置進來的domainname或ip    server_name localhost;    # 設置routing    location / &#123;    \t# 轉發        proxy_pass http://localhost:9001;        # 轉發request的header內容        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;    &#125;&#125;\n\n設定loadbalance# 設置輪巡節點upstream servicemapping &#123;    server 127.0.0.1:9001 weight=3;    server 127.0.0.1:9002 weight=2;&#125;server &#123;\t# 監聽 80 port    listen 80;    listen [::]:80;    # 設置進來的domainname或ip    server_name my.app.test;\t# 設置routing    location / &#123;    \t# 轉發        proxy_pass http://servicemapping;        # 轉發request的header內容        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;    &#125;&#125;\n\n兩次請求結果\n","categories":["nginx"],"tags":["linux","nginx"]},{"title":"Ubuntu安裝PM2","url":"/2019/03/24/pm2-install/","content":"PM2是一套Node應用的進程管理器，當程式出現錯誤或者其他狀況死掉之後，這時候PM2就可以幫你的應用自動重啟，當然它不止這些功能，詳細可以看看官網介紹：PM2\n\n\n接下來我們要來介紹如何在ububtu上安裝它\n先更新套件：\n$ sudo apt update$ sudo apt upgrade\n\n安裝NodeJS已經安裝過的朋友可以跳過這一步\n安装NodeJS：\n$ sudo apt install nodejs\n然後我們要安裝n來幫我們管理nodejs版本：\n$ npm install -g n\n\n安裝NPM已經安裝過的朋友可以跳過這一步\n安装NPM：\n$ sudo apt install npm\n然後我們要安裝n來幫我們管理nodejs版本：\n$ npm install -g n\n\n安裝PM2接下來要開始正式安裝PM2：\n$ npm install pm2 -g\n完成PM2安裝步驟：\n$ pm2 completion install\n查看監控項目列表：\n$ pm2 ls\n\n查看監控詳細內容：\n$ pm2 monit\n","categories":["pm2"],"tags":["ubuntu","linux","pm2"]},{"title":"PM2監控程序","url":"/2019/03/24/pm2-watch/","content":"接下來我們要介紹如何簡單的監控我們應用\n\n\n測試腳本我們寫個簡單的腳本\nnano test.sh#!/bin/bashecho test is startfor v in &#123;1..10&#125;do\techo this is a echo\tsleep 1doneecho test is end\n\n建立PM2配置pm2允許我通過配置的方式來控制我們想要監控的方式，所以我們先產生一個基本的範例：\n$ pm2 init\npm2會幫我們產生一個名為ecosystem.config.js的檔案\n編輯PM2配置接下來要編輯這個檔案配置\nmodule.exports = &#123;  apps : [&#123;    name: &#x27;mytest&#x27;, // 任務名稱    script: &#x27;test.sh&#x27;, // 啟動腳本    // Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/    //args: &#x27;one two&#x27;,    instances: 1,    autorestart: true, // 自動重啟開關    max_restarts: 10, // 最大重啟次數    restart_delay: 30000, // 重啟時間間隔(毫秒)    watch: false,    max_memory_restart: &#x27;1G&#x27;,    env: &#123;      NODE_ENV: &#x27;development&#x27;    &#125;,    env_production: &#123;      NODE_ENV: &#x27;production&#x27;    &#125;  &#125;],  deploy : &#123;    production : &#123;      user : &#x27;node&#x27;,      host : &#x27;127.0.0.1&#x27;,      ref  : &#x27;origin/master&#x27;,      repo : &#x27;git@github.com:repo.git&#x27;,      path : &#x27;/var/www/production&#x27;,      &#x27;post-deploy&#x27; : &#x27;npm install &amp;&amp; pm2 reload ecosystem.config.js --env production&#x27;    &#125;  &#125;&#125;;\n\n操作PM2任務啟動任務：\n$ pm2 start ecosystem.config.js\n\n停止任務：\n$ pm2 stop ecosystem.config.js\n\n觀看監控：\n$ pm2 monit\n\n\n更多的介紹請上官網查詢：PM2教程\n","categories":["pm2"],"tags":["linux","pm2"]},{"title":"美化 PowerShell：Oh My Posh 全攻略 (2025)","url":"/2025/09/18/powershell-improve-2025/","content":"最近把內建的 Windows PowerShell 5.1 直接升級到跨平台的 PowerShell 7，啟動速度、互動補全與外觀自訂一次大進化。於是把這次從「升級 → 權限工具 (gsudo) → Prompt 美化 (Oh My Posh) → 文字&#x2F;字型 → 終端顏色主題」的完整流程整理成筆記，之後重裝或換機也能快速複製。 \n這篇你將會獲得：\n\n乾淨可重現的 Profile 初始化步驟\n提升效率的補全與權限操作設定\n一套漂亮又資訊量足夠的 Prompt 主題\nWindows Terminal 配色與字型建議\n\n先來看看升級前「尚未美化」的樣子，然後開始改造：\n\n\n\n\nPowerShell Profile 準備之後的功能（自動補全、別名、提示主題等）都會寫進個人 Profile。先確認目前的 $PROFILE 是否存在，沒有就建立。\n# 查看目前使用的 Profile 路徑echo $PROFILE# 檢查檔案是否存在（True = 已存在）Test-Path $PROFILE# 直接用記事本編輯notepad $PROFILE\n\nWindows PowerShell 5.1 目錄舊版（內建）使用的目錄名稱是 WindowsPowerShell。\n# 檢查舊版目錄是否存在Test-Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\WindowsPowerShell&quot;# 建立目錄（若不存在）New-Item -ItemType Directory -Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\WindowsPowerShell&quot; -Force# 建立 Profile（空檔案）New-Item -ItemType File -Path $PROFILE -Force\n\nPowerShell 7 目錄PowerShell 7 之後改用新目錄 PowerShell，不要混用。\n# 檢查新版目錄是否存在Test-Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\PowerShell&quot;# 建立目錄New-Item -ItemType Directory -Path &quot;C:\\Users\\&#123;你的帳戶&#125;\\Documents\\PowerShell&quot; -Force# 建立 ProfileNew-Item -ItemType File -Path $PROFILE -Force\n\n安裝 PowerShell 7使用 winget 最方便：\n# 安裝winget install --id Microsoft.Powershell --source winget# 更新winget upgrade --id Microsoft.Powershell\n\n啟用指令歷史 + AI 預測補全建議在 Profile 中加入 PSReadLine 設定：\n# 使用歷史紀錄 (History) + 外掛/擴充來源 (Plugin) 同時提供預測建議。# 其他可選值：None / History / Plugin / HistoryAndPluginSet-PSReadLineOption -PredictionSource HistoryAndPlugin# 將多筆建議以清單面板顯示於游標下方（ListView）。# 若偏好行內灰色字體，可改用：InlineViewSet-PSReadLineOption -PredictionViewStyle ListView\n\n若想立即測試：把以上貼進 notepad $PROFILE 開啟的檔案末端後存檔，再開新視窗生效。\ngsudo：快速取得系統權限gsudo 可視為 Windows 版 sudo，不用每次再手動啟動「以系統管理員身分執行」。\n# 安裝winget install gerardog.gsudo# 更新winget upgrade gerardog.gsudo\n\n在 Profile 中加入別名：\nSet-Alias sudo gsudo\n\n如果在 Windows Terminal 中想建立一個自動提權啟動 PowerShell 7 的命令，可在設定中指定：\ngsudo.exe &quot;C:\\Program Files\\PowerShell\\7\\pwsh.exe&quot;\n\n\n\nOh My Posh：Prompt 主題美化安裝 Nerd Font 字型先到 Nerd Fonts 官網 下載一款字型（建議 FiraCode &#x2F; Meslo &#x2F; JetBrainsMono），安裝後到 Windows Terminal 的該 Profile 內套用，避免符號亂碼。\n安裝 Oh My Poshwinget install JanDeDobbeleer.OhMyPosh -s wingetwinget upgrade JanDeDobbeleer.OhMyPosh\n\n啟用並指定主題在 Profile 內加入（可先用 notepad $PROFILE 開啟）：\n# 初始化（預設主題）oh-my-posh init pwsh | Invoke-Expression# 指定 paradox 主題（可改成任意 .omp.json）oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\paradox.omp.json&quot; | Invoke-Expression\n\n查看有哪些內建主題：\nGet-ChildItem $env:POSH_THEMES_PATH -Recurse -Filter &quot;*.omp.json&quot;\n\n修改後重新開一個新的 PowerShell 視窗即可看到效果。\n安裝 Git（若尚未安裝）winget install --id Git.Git -e --source wingetwinget upgrade Git.Git\n\nWindows Terminal 主題配色（Schemes）可到 Windows Terminal Themes 挑選喜歡的色票，將 JSON 片段貼進設定檔的 schemes 陣列，再於對應 Profile 設 &quot;colorScheme&quot; 為該名稱。\n\n\n例如 Espresso：\n&#123;  &quot;background&quot;: &quot;#323232&quot;,  &quot;black&quot;: &quot;#353535&quot;,  &quot;blue&quot;: &quot;#6C99BB&quot;,  &quot;brightBlack&quot;: &quot;#535353&quot;,  &quot;brightBlue&quot;: &quot;#8AB7D9&quot;,  &quot;brightCyan&quot;: &quot;#DCF4FF&quot;,  &quot;brightGreen&quot;: &quot;#C2E075&quot;,  &quot;brightPurple&quot;: &quot;#EFB5F7&quot;,  &quot;brightRed&quot;: &quot;#F00C0C&quot;,  &quot;brightWhite&quot;: &quot;#FFFFFF&quot;,  &quot;brightYellow&quot;: &quot;#E1E48B&quot;,  &quot;cursorColor&quot;: &quot;#D6D6D6&quot;,  &quot;cyan&quot;: &quot;#BED6FF&quot;,  &quot;foreground&quot;: &quot;#FFFFFF&quot;,  &quot;green&quot;: &quot;#A5C261&quot;,  &quot;name&quot;: &quot;Espresso&quot;,  &quot;purple&quot;: &quot;#D197D9&quot;,  &quot;red&quot;: &quot;#D25252&quot;,  &quot;selectionBackground&quot;: &quot;#5B5B5B&quot;,  &quot;white&quot;: &quot;#EEEEEC&quot;,  &quot;yellow&quot;: &quot;#FFC66D&quot;&#125;\n\n開啟 JSON 設定：\n\n\n\n將上述片段加入 schemes。\n在對應的 Profile 中設定：&quot;colorScheme&quot;: &quot;Espresso&quot;。\n\nVS Code 終端機設定如果你有在使用 VS Code，記得同步調整編輯器內建終端機的字型設定，否則 Oh My Posh 的特殊符號會出現亂碼。\n設定步驟\n開啟 VS Code 設定（Ctrl + , 或 File &gt; Preferences &gt; Settings）\n搜尋 terminal.integrated.fontFamily\n將字型設定為你剛才安裝的 Nerd Font，例如：&#x27;FiraCode Nerd Font&#x27;, &#x27;Meslo LG M DZ for Powerline&#x27;, Consolas, &#x27;Courier New&#x27;, monospace\n\n建議設定值&#123;  &quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;FiraCode Nerd Font&#x27;&quot;,  &quot;terminal.integrated.fontSize&quot;: 14,  &quot;terminal.integrated.cursorBlinking&quot;: true,  &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;&#125;\n\n這樣設定後，VS Code 內建終端機就能正確顯示 Oh My Posh 的所有圖示和符號了。\n\n\n成果展示\n\n希望這篇能幫助你快速打造一個好看、好讀、好用的終端環境。如果你有更喜歡的主題或額外技巧，也歡迎分享交流 🙌\n","categories":["windows"],"tags":["windows","powershell","terminal","vscode"]},{"title":"美化PowerShell - oh-my-posh","url":"/2020/03/08/powershell-improve/","content":"\n\n厭倦windows預設的powershell主題了嗎?現在開始來改造它吧!!!\n\n\n安裝套件首先打開powershell：\n# 安裝posh-git套件Install-Module posh-git -Scope CurrentUser# 安裝oh-my-posh套件Install-Module oh-my-posh -Scope CurrentUser\n基本上都輸入Y到底就可以安裝完成了!\n設置設定檔建立powershel啟動設定檔\n# 取得設定檔位置$profile# 得到設定檔位置~\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\n打開Microsoft.PowerShell_profile.ps1設定檔，如果沒有請自行建立\n# 使用UTF-8編碼chcp 65001# 引用posh-gitImport-Module posh-git# 引用oh-my-poshImport-Module oh-my-posh# 設置Agnoster主題Set-Theme Agnoster\n\n安裝powerline字型由於windows預設的字型無法支援oh-my-posh所以我們需要另外安裝配合的字型檔\npowerline字型\n# clone項目git clone https://github.com/powerline/fonts.git# 執行install.ps1進行安裝.\\install.ps1\n\n調整powershell內容\n\n\n請選擇有powerline的字型\n\n\n配置顏色主題最後我們要用scoop來安裝colortool主題工具\n# 保證允許腳本執行set-executionpolicy remotesigned -scope currentuser# 安裝scoopiex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)# 安裝colortoolscoop install colortool\n接著我們就要來配置顏色主題\n# 取得預設主題列表colortool -s# 預設主題# campbell-legacy.ini# campbell.ini# cmd-legacy.ini# OneHalfDark.itermcolors# OneHalfLight.itermcolors# solarized_dark.itermcolors# solarized_light.itermcolors# 臨時查看主題樣式colortool &lt;主題名稱&gt;# 設置預設主題樣式colortool -d &lt;主題名稱&gt;\n\n選定主題\n# 設置OneHalfDark主題colortool OneHalfDark.itermcolors\n\n\n\n這樣我們就大功告成拉!!\n","categories":["windows"],"tags":["windows","powershell","terminal"]},{"title":"Ubuntu安裝RabbitMQ","url":"/2020/05/10/rabbitmq-install/","content":"安裝erlangrabbitmq需要依靠erlang驅動，所以我們需要先安裝erlang\n使用repository安裝:\n$ wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb$ sudo dpkg -i erlang-solutions_2.0_all.deb$ sudo apt install esl-erlang\n\n安裝rabbitmqgithub手動安裝:\n$ wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server_3.8.3-1_all.deb$ sudo dpkg -i rabbitmq-server_3.8.3-1_all.deb\n\n\n\n如果安裝過程有問題可以試著apt指令修復\n$ sudo apt --fix-broken install\n\n修改rabbitmq管理插件安裝完rabbitmq之後,我們會需要一個可以管理的工具,rabbitmq很好的提供web的管理工具\n$ rabbitmq-plugins enable rabbitmq_management\n\n安裝完畢後重啟服務接著在瀏覽器輸入http://localhost:15672\n\n\n修改rabbitmq設置因為rabbitmq預設guest帳號只給本機登入，如果需要開放外部登入就要修改設置\n打開&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config，加入以下設置\n[\t&#123;\t\trabbit,\t\t[&#123;loopback_users, [&quot;guest&quot;]&#125;]\t&#125;].\n\n重啟服務之後我們就可以用guset帳號登入了\n","categories":["linux"],"tags":["ubuntu","linux","rabbitmq"]},{"title":"TelegramBot申請與開發","url":"/2019/11/09/telegrambot-install/","content":"telegrambot的使用與開發相較於linebot來說是好上手很多接下來就是介紹開發與使用方式\n\n\ntelegrambot 申請在telegram search bar上搜尋@BotFather然後完成附圖的流程\n\n\ntelegrambot API使用https://api.telegram.org/bot&#123;token&#125;/getUpdates# 取得chatid&#123;    &quot;ok&quot;: true,    &quot;result&quot;: [        &#123;            &quot;update_id&quot;: 123456789,            &quot;message&quot;: &#123;                &quot;message_id&quot;: 99,                &quot;from&quot;: &#123;                    &quot;id&quot;: 123456789,                    &quot;is_bot&quot;: false,                    &quot;first_name&quot;: &quot;&quot;,                    &quot;last_name&quot;: &quot;&quot;,                    &quot;username&quot;: &quot;&quot;,                    &quot;language_code&quot;: &quot;&quot;                &#125;,                &quot;chat&quot;: &#123;                    &quot;id&quot;: -314847207,                    &quot;title&quot;: &quot;this is a title&quot;,                    &quot;type&quot;: &quot;group&quot;,                    &quot;all_members_are_administrators&quot;: true                &#125;,                &quot;date&quot;: 1573288754,                &quot;text&quot;: &quot;messsage&quot;            &#125;        &#125;    ]&#125;\n\nhttps://api.telegram.org/bot&#123;token&#125;/sendMessage?chat_id=&#123;channelid&#125;&amp;text=&#123;message&#125;# 嘗試發送訊息&#123;    &quot;ok&quot;: true,    &quot;result&quot;: &#123;        &quot;message_id&quot;: 99,        &quot;from&quot;: &#123;            &quot;id&quot;: 123456789,            &quot;is_bot&quot;: true,            &quot;first_name&quot;: &quot;&quot;,            &quot;username&quot;: &quot;&quot;        &#125;,        &quot;chat&quot;: &#123;            &quot;id&quot;: 123456789,            &quot;title&quot;: &quot;this is a title&quot;,            &quot;type&quot;: &quot;group&quot;,            &quot;all_members_are_administrators&quot;: true        &#125;,        &quot;date&quot;: 1573289062,        &quot;text&quot;: &quot;messsage&quot;    &#125;&#125;\n\n更多API參考 Telegram Bot API\ntelegrambot JAVASDK使用maven引用\n&lt;dependency&gt;  &lt;groupId&gt;org.telegram&lt;/groupId&gt;  &lt;artifactId&gt;telegrambots&lt;/artifactId&gt;  &lt;version&gt;4.4.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n繼承TelegramLongPollingBot\n@Overridepublic String getBotUsername()&#123;\treturn &quot;userName&quot;;&#125;@Overridepublic String getBotToken()&#123;\treturn &quot;token&quot;;&#125;@Overridepublic void onUpdateReceived(Update update)&#123;\tif (update.hasMessage() &amp;&amp; update.getMessage().hasText())\t&#123;\t\tUser user = update.getMessage().getFrom();\t\tString rcvMessage = update.getMessage().getText();\t\tString source = String.format(&quot;收到來自[%s%s]的訊息內容=%s&quot;, user.getFirstName(), user.getLastName(), rcvMessage);\t\tSendMessage message = new SendMessage().setChatId(update.getMessage().getChatId()).setText(source);\t\ttry\t\t&#123;\t\t\texecute(message);\t\t&#125;\t\tcatch (Exception e)\t\t&#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\nBotClass使用\npublic static void main(String[] args)&#123;\tApiContextInitializer.init();\tTelegramBotsApi botsApi = new TelegramBotsApi();\ttry\t&#123;\t\tbotsApi.registerBot(new Telegram());\t&#125;\tcatch (Exception e)\t&#123;\t\te.printStackTrace();\t&#125;&#125;\n\n最後完成範例\n","categories":["telegram"],"tags":["telegram","bot"]},{"title":"安裝Tomcat","url":"/2019/03/16/tomcat-install/","content":"安裝Tomcat先下載maven：\n$ wget https://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.16/bin/apache-tomcat-9.0.16.tar.gz\n解開包：\n$ tar xzvf apache-tomcat-9.0.16.tar.gz\n移動到&#x2F;opt&#x2F;底下：\n$ mv apache-tomcat-9.0.16 /opt\n\n設置Tomcat環境變數打開&#x2F;etc&#x2F;profile這個檔案並且在末尾加入：\nexport TOMCAT_HOME=/opt/apache-tomcat-9.0.16export PATH=$PATH:$TOMCAT_HOME/bin","categories":["tomcat"],"tags":["linux","tomcat"]},{"title":"Ubuntu安裝Redis","url":"/2019/03/16/ubuntu-installredis/","content":"安裝redis在ubuntu底下安裝redis跟安裝mariadb一樣，依靠apt指令就可以安裝完成：\n先更新套件：\n$ sudo apt update$ sudo apt upgrade\n\n安装Redis：\n$ sudo apt install redis-server\n\n安裝完成後redis會自動加入到服務中，查看服務：\n$ sudo systemctl status redis\n\n\n\n修改redis設置後我們要提供給遠端使用者使用就需要去修改設定檔，打開&#x2F;etc&#x2F;redis&#x2F;redis.conf，找到bind且將他註解掉\n# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# bind 127.0.0.1 ::1\n\n之後再重新啟動redis就可以了\n$ sudo systemctl restart redis","categories":["linux"],"tags":["ubuntu","linux","redis"]},{"title":"Ubuntu安裝MariaDB","url":"/2019/03/16/ubuntu-installmariadb/","content":"安裝mariadb在ubuntu底下安裝mariadb其實很方便，只要幾個指令就可以完成了：\n先更新套件：\n$ sudo apt update$ sudo apt upgrade\n\n安装MariaDB：\n$ sudo apt install mariadb-server\n\n啟動服務：\n$ sudo systemctl start mysql$ sudo systemctl enable mysql\n\n查看服務：\n$ sudo systemctl status mysql\n\n\n\n初始化mariadb$ sudo mysql_secure_installation# 是否要設置root權限密碼- Set root password? [Y/n] y# 是否要移除匿名登入- Remove anonymous users? [Y/n] y# 是否關閉遠端登入- Disallow root login remotely? [Y/n] y# 是否移除test預設庫- Remove test database and access to it? [Y/n] y# 是否重新載入資料表權限- Reload privilege tables now? [Y/n] y\n\n完成後我們可試著本機登入查看：\n$ sudo mysql -u root -p\n\n建立遠端使用者權限初始化db之後我們還需要建立一組帳號，提供使用者遠端登入使用\n建立使用者與權限：\n# 建立使用者$ CREATE USER &#x27;my_account&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;my_password&#x27;;# 建立使用者權限$ GRANT ALL PRIVILEGES ON *.* TO &#x27;my_account&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;my_password&#x27; WITH GRANT OPTION;# 刷新設置$ FLUSH PRIVILEGES;\n\n查看結果：\n# 查看使用者$ SELECT host,user,password FROM mysql.user;# 查看使用者權限$ SHOW GRANTS FOR &#x27;my_account&#x27;;\n\n完成後我們嘗試遠端登入查看：\n$ mysql -h 192.168.0.100 -u &#x27;my_account&#x27; -p\n\n修改mariadb設置如果還是不行就需要去修改mariadb的設定檔打開&#x2F;etc&#x2F;mysql&#x2F;mariadb.conf.d&#x2F;50-server.cnf，找到bind-address且將他註解掉\n# Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.# bind-address  = 127.0.0.1\n\n之後再重新啟動mariadb就可以了\n$ sudo systemctl restart mysql","categories":["linux"],"tags":["ubuntu","linux","mariadb"]},{"title":"使用vscode+copilot快速建立專案","url":"/2025/07/30/vscode-copilot-quick/","content":"從 Eclipse 到 VSCode：我的 AI 輔助開發轉型之路嗨大家好！今天想跟大家分享一個讓我既興奮又有點緊張的決定 —— 我要從用了好幾年的 Eclipse 跳槽到 VSCode 了！🚀\n為什麼決定換編輯器？老實說，作為一個 Java 開發者，Eclipse 一直是我的好夥伴。但最近看到越來越多同事在用 VSCode，特別是搭配 GitHub Copilot 的開發體驗，讓我開始好奇：「我是不是錯過了什麼？」\n更重要的是，現在 AI 輔助開發工具發展得這麼快，我覺得是時候跟上這個潮流了。畢竟，誰不想寫 code 寫得更快、更聰明呢？😄\n準備好了嗎？讓我們一起踏上這段 AI 輔助開發的冒險之旅吧！ 🎉\n\n\n這篇文章會聊什麼？這次我想分享的重點是：如何用 VSCode + GitHub Copilot + 自定義 Prompts 來快速建立 Spring Boot 專案。\n具體來說，我會分享給大家：\n\n🎯 使用 .github/prompts/*.prompt.md 自定義提示詞\n⚡ 展示讓 AI 幫你快速搭建專案架構\n💡 一些我在轉換過程中學到的小技巧\n\n這次的實戰內容我錄了一個完整的操作影片，從零開始建立一個 Spring Boot 專案：\n📺 實戰教學影片：VSCode + AI 快速建立 Spring Boot 專案\n\n  \n    \n    \n  \n\n\n影片裡我會展示：\n\nVSCode 環境的基本設定\nGitHub Copilot 的神奇功能\n自定義 Prompt 模板的設計技巧\n實際建立一個可運行的 Spring Boot 應用\n\n使用體驗真實感想老實說，剛開始使用 VSCode + GitHub Copilot 的時候，我真的被震撼到了！😱\n流暢度方面：\n\n🚀 啟動速度：從點擊到可以開始寫 code，幾乎是秒開！跟 Eclipse 那種「先去泡杯咖啡」的等待完全不同\n⚡ 反應速度：打字的時候沒有任何延遲感，檔案切換也是瞬間完成\n🎯 記憶體使用：明顯比傳統 IDE 輕量很多，多開幾個專案也不會讓電腦卡到爆\n\nAI 輔助的驚艷之處：\n\n🧠 任務規劃能力：最讓我震撼的是 Copilot 能夠理解整個專案的架構，當我說「建立一個 Spring Boot 專案」時，它不只是給我片段程式碼，而是能建立一個完整可執行的專案\n🔥 執行效率：從 Controller、Service、Repository 到測試檔案的建立，整個流程一氣呵成，就像有個經驗豐富的 Senior 在旁邊協助\n🎯 上下文理解：它會記住我之前寫的程式碼風格和專案結構，新增的程式碼都能完美融入既有的架構中\n💡 智能補全：不只是簡單的語法補全，它會根據上下文給出完整的函式實作，甚至包含錯誤處理\n📝 文件生成：連 README、API 文件、註解都能自動生成，而且寫得比我還詳細（有點害羞 😅）\n\n最讓我驚嘆的是：整個開發流程變得非常「自然」，就像在跟一個很懂你的夥伴協作。以前寫 code 需要頻繁查文件、想語法，現在很多時候 AI 就直接給出了我要的答案。\n這種感覺就像從「手動檔」換到「自動檔」一樣 —— 你還是在開車，但整個過程變得更順暢、更專注在真正重要的邏輯思考上。\n\n我會不定期分享更多 VSCode + AI 開發的實戰體驗！ 🎉\n","categories":["vscodelife"],"tags":["java","vscode","github-copilot"]},{"title":"vscode+copilot開發心得","url":"/2025/09/14/vscode-copilot-thoughts/","content":"前言距離上一篇 使用 vscode+copilot 快速建立專案 已經快兩個月。這段時間我把以前的專案拿來當練手題，持續用 vscode 搭配 Copilot 做重構，最近算是到了一個階段性的里程碑，也比較有資格整理一下心得與體感。\n成果速覽先放結果：tinysocket。下面這張是目前 README.md 的截圖：\n\n\n\n\n文件撰寫體驗老實說，過去我非常不擅長寫說明文件——常常卡在措辭或結構。換上 vscode + Copilot 之後，整體心理阻力明顯下降。我只需要丟一句：替專案進行完整的分析並生成適合的文檔，它就會開始產出內容。雖然：\n\n產出的語氣常常有一種「過度熱情」或統一的 AI 風格。\n偶爾會出現 幻覺（虛構不存在的模組 &#x2F; 參數 &#x2F; 流程）。\n\n但在「快速產出草稿」這件事上，效率提升非常明顯。現在的流程變成：AI 出草稿 → 我做實際校驗與語氣調整 → 完成最終版本。整體投入的心力與時間成本都下降。\n重構與技術升級這次 tinysocket 從過去的 JDK 11 + Spring Boot 2，一次跳到 JDK 21 + Spring Boot 3。在重構過程中我順手調整了幾個長期想改的點：\n\nbuffer 的實作策略（記憶體使用與複用模型）\nprotocol 的註冊與擴充方式（模組化與可插拔）\nserver-side &#x2F; client-side 邏輯的職責切分\n\n整體代碼結構乾淨很多，開發迭代的節奏也更順。雖然還不到「vibe coding」那種一氣呵成的沉浸流暢，但 AI 輔助開發是實實在在幫助我產出想要的結果。這一次我沒有花太多時間鑽研 copilot-instructions.md 或 spec.md 的進階玩法——純粹以「自然互動」的使用模式，就已經有不錯的感受。更直接的感想：vscode + Copilot 的體驗完全碾壓 eclipse + Copilot。如果未來 Copilot 還是無法在 eclipse 深度整合，那我會建議乾脆直接轉陣 vscode。\n前端 Demo（AI 協作）我不擅長開發前端，也只略懂一點 JS。之前為了展示 tinysocket 的 websocket 使用情境，勉強刻過一個很陽春的 demo。這次升級時我把那個頁面也一起翻新。過程很簡單：我描述現有專案結構、想要的互動與狀態，Copilot 在幾分鐘內就給了一個「能跑、有基本結構與樣式」的版本。我後面再針對細節（排版 &#x2F; 邏輯微調 &#x2F; 錯誤處理）做修正。雖然不至於到震撼，但在第一次產出結果的瞬間，實際的衝擊感還是有的。\n以下是最後的 demo 截圖：\n\n\n單元測試與未來工作模式這次我沒有非常認真地補齊所有單元測試，但試著讓 Copilot 幫忙規劃測試場景與生產測試骨架。體感結論是：「單元測試 80% 可以交給 AI 先起頭」。透過自然語言描述：需求 → 邊界條件 → 例外情境，AI 就能快速鋪好一組測試檔。後續人類再專注在：\n\n釐清語意是否與實際需求一致\n補強 edge cases\n整合 CI &#x2F; coverage 門檻\n\n未來真的可能變成：測試從『手寫產出』轉為『審稿驗收』模式。\n結語簡單總結：工具與工作方式的生態正在快速轉變。AI 不是「取代」，而是把重構 &#x2F; 起稿 &#x2F; 模板化工作成本往下壓，讓我們把腦力留給系統設計、關鍵抽象與品質判斷。接下來我會再花些時間探索更進階的上下文餵養（如專案規格、角色化指令），之後如果有新的體驗，再寫一篇續集。 \n我們下次見。\n","categories":["vscodelife"],"tags":["java","vscode","github-copilot"]},{"title":"Windows Terminal主題配置","url":"/2020/03/09/windowsterminal-scheme/","content":"\n\n\n\n打開WindowsTerminal的Setting設置主題\nDracula主題\n&quot;profiles&quot;:[\t&#123;\t\t&quot;name&quot;: &quot;Windows PowerShell&quot;,\t\t&quot;commandline&quot;: &quot;powershell.exe&quot;,\t\t&quot;cursorColor&quot; : &quot;#657B83&quot;, // 光標顏色\t\t&quot;cursorShape&quot; : &quot;vintage&quot;, // 光標類型\t\t&quot;colorScheme&quot; : &quot;Dracula&quot;, // 配置主題\t\t&quot;fontFace&quot; : &quot;DejaVu Sans Mono for Powerline&quot;, // 字型\t\t&quot;fontSize&quot; : 12, // 字型大小\t\t&quot;hidden&quot;: false\t&#125;,\t&#123;\t\t&quot;name&quot;: &quot;cmd&quot;,\t\t&quot;commandline&quot;: &quot;cmd.exe&quot;,\t\t&quot;cursorColor&quot; : &quot;#657B83&quot;,\t\t&quot;cursorShape&quot; : &quot;vintage&quot;,\t\t&quot;colorScheme&quot; : &quot;Dracula&quot;,\t\t&quot;fontFace&quot; : &quot;DejaVu Sans Mono for Powerline&quot;,\t\t&quot;fontSize&quot; : 12,\t\t&quot;hidden&quot;: false\t&#125;],&quot;schemes&quot;:[\t&#123;\t\t&quot;name&quot; : &quot;Dracula&quot;,\t\t&quot;background&quot; : &quot;#282A36&quot;,\t\t&quot;black&quot; : &quot;#21222C&quot;,\t\t&quot;blue&quot; : &quot;#BD93F9&quot;,\t\t&quot;brightBlack&quot; : &quot;#6272A4&quot;,\t\t&quot;brightBlue&quot; : &quot;#D6ACFF&quot;,\t\t&quot;brightCyan&quot; : &quot;#A4FFFF&quot;,\t\t&quot;brightGreen&quot; : &quot;#69FF94&quot;,\t\t&quot;brightPurple&quot; : &quot;#FF92DF&quot;,\t\t&quot;brightRed&quot; : &quot;#FF6E6E&quot;,\t\t&quot;brightWhite&quot; : &quot;#FFFFFF&quot;,\t\t&quot;brightYellow&quot; : &quot;#FFFFA5&quot;,\t\t&quot;cyan&quot; : &quot;#8BE9FD&quot;,\t\t&quot;foreground&quot; : &quot;#F8F8F2&quot;,\t\t&quot;green&quot; : &quot;#50FA7B&quot;,\t\t&quot;purple&quot; : &quot;#FF79C6&quot;,\t\t&quot;red&quot; : &quot;#FF5555&quot;,\t\t&quot;white&quot; : &quot;#F8F8F2&quot;,\t\t&quot;yellow&quot; : &quot;#F1FA8C&quot;\t&#125;],","categories":["windows"],"tags":["windows","powershell","terminal"]}]